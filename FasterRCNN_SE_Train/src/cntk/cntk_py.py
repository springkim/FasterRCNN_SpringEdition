# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_cntk_py')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_cntk_py')
    _cntk_py = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_cntk_py', [dirname(__file__)])
        except ImportError:
            import _cntk_py
            return _cntk_py
        if fp is not None:
            try:
                _mod = imp.load_module('_cntk_py', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _cntk_py = swig_import_helper()
    del swig_import_helper
else:
    import _cntk_py
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cntk_py.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _cntk_py.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _cntk_py.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _cntk_py.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _cntk_py.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _cntk_py.SwigPyIterator_equal(self, x)

    def copy(self):
        return _cntk_py.SwigPyIterator_copy(self)

    def next(self):
        return _cntk_py.SwigPyIterator_next(self)

    def __next__(self):
        return _cntk_py.SwigPyIterator___next__(self)

    def previous(self):
        return _cntk_py.SwigPyIterator_previous(self)

    def advance(self, n):
        return _cntk_py.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _cntk_py.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _cntk_py.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _cntk_py.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _cntk_py.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _cntk_py.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _cntk_py.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _cntk_py.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _cntk_py.SHARED_PTR_DISOWN
class SizeTWrapper(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SizeTWrapper, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SizeTWrapper, name)
    __repr__ = _swig_repr
    __swig_setmethods__["value"] = _cntk_py.SizeTWrapper_value_set
    __swig_getmethods__["value"] = _cntk_py.SizeTWrapper_value_get
    if _newclass:
        value = _swig_property(_cntk_py.SizeTWrapper_value_get, _cntk_py.SizeTWrapper_value_set)

    def __init__(self, *args):
        this = _cntk_py.new_SizeTWrapper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_SizeTWrapper
    __del__ = lambda self: None
SizeTWrapper_swigregister = _cntk_py.SizeTWrapper_swigregister
SizeTWrapper_swigregister(SizeTWrapper)

InferredDimension = _cntk_py.InferredDimension
FreeDimension = _cntk_py.FreeDimension

def is_within(*args):
    return _cntk_py.is_within(*args)
is_within = _cntk_py.is_within

def packed_index(*args):
    return _cntk_py.packed_index(*args)
packed_index = _cntk_py.packed_index

def gather_packed(*args):
    return _cntk_py.gather_packed(*args)
gather_packed = _cntk_py.gather_packed

def scatter_packed(*args):
    return _cntk_py.scatter_packed(*args)
scatter_packed = _cntk_py.scatter_packed

def zeroes_with_dynamic_axes_like(operand):
    return _cntk_py.zeroes_with_dynamic_axes_like(operand)
zeroes_with_dynamic_axes_like = _cntk_py.zeroes_with_dynamic_axes_like

def reduce_elements(*args):
    return _cntk_py.reduce_elements(*args)
reduce_elements = _cntk_py.reduce_elements

def save_as_legacy_model(rootFunction, modelFile):
    return _cntk_py.save_as_legacy_model(rootFunction, modelFile)
save_as_legacy_model = _cntk_py.save_as_legacy_model

def new_unique_id():
    return _cntk_py.new_unique_id()
new_unique_id = _cntk_py.new_unique_id

def generate_random_seed(perWorkerLocalValue=False):
    return _cntk_py.generate_random_seed(perWorkerLocalValue)
generate_random_seed = _cntk_py.generate_random_seed

def enable_reversing_tensor_shapes_in_error_messages():
    return _cntk_py.enable_reversing_tensor_shapes_in_error_messages()
enable_reversing_tensor_shapes_in_error_messages = _cntk_py.enable_reversing_tensor_shapes_in_error_messages

def always_allow_setting_default_device():
    return _cntk_py.always_allow_setting_default_device()
always_allow_setting_default_device = _cntk_py.always_allow_setting_default_device

def allow_renaming_functions():
    return _cntk_py.allow_renaming_functions()
allow_renaming_functions = _cntk_py.allow_renaming_functions

def set_automatic_unpacking_of_packed_values(disable):
    return _cntk_py.set_automatic_unpacking_of_packed_values(disable)
set_automatic_unpacking_of_packed_values = _cntk_py.set_automatic_unpacking_of_packed_values

def set_computation_network_trace_level(traceLevel):
    return _cntk_py.set_computation_network_trace_level(traceLevel)
set_computation_network_trace_level = _cntk_py.set_computation_network_trace_level

def set_gpumemory_allocation_trace_level(traceLevel):
    return _cntk_py.set_gpumemory_allocation_trace_level(traceLevel)
set_gpumemory_allocation_trace_level = _cntk_py.set_gpumemory_allocation_trace_level

def set_math_lib_trace_level(traceLevel):
    return _cntk_py.set_math_lib_trace_level(traceLevel)
set_math_lib_trace_level = _cntk_py.set_math_lib_trace_level

def force_deterministic_algorithms():
    return _cntk_py.force_deterministic_algorithms()
force_deterministic_algorithms = _cntk_py.force_deterministic_algorithms

def should_force_deterministic_algorithms():
    return _cntk_py.should_force_deterministic_algorithms()
should_force_deterministic_algorithms = _cntk_py.should_force_deterministic_algorithms

def enable_synchronous_gpukernel_execution():
    return _cntk_py.enable_synchronous_gpukernel_execution()
enable_synchronous_gpukernel_execution = _cntk_py.enable_synchronous_gpukernel_execution

def is_synchronous_gpukernel_execution_enabled():
    return _cntk_py.is_synchronous_gpukernel_execution_enabled()
is_synchronous_gpukernel_execution_enabled = _cntk_py.is_synchronous_gpukernel_execution_enabled

def use_sparse_gradient_aggregation_in_data_parallel_sgd(enable):
    return _cntk_py.use_sparse_gradient_aggregation_in_data_parallel_sgd(enable)
use_sparse_gradient_aggregation_in_data_parallel_sgd = _cntk_py.use_sparse_gradient_aggregation_in_data_parallel_sgd

def should_use_sparse_gradient_aggregation_in_data_parallel_sgd():
    return _cntk_py.should_use_sparse_gradient_aggregation_in_data_parallel_sgd()
should_use_sparse_gradient_aggregation_in_data_parallel_sgd = _cntk_py.should_use_sparse_gradient_aggregation_in_data_parallel_sgd

def get_random_seed():
    return _cntk_py.get_random_seed()
get_random_seed = _cntk_py.get_random_seed

def set_fixed_random_seed(value):
    return _cntk_py.set_fixed_random_seed(value)
set_fixed_random_seed = _cntk_py.set_fixed_random_seed

def is_random_seed_fixed():
    return _cntk_py.is_random_seed_fixed()
is_random_seed_fixed = _cntk_py.is_random_seed_fixed

def reset_random_seed(value=0):
    return _cntk_py.reset_random_seed(value)
reset_random_seed = _cntk_py.reset_random_seed

def enable_forward_values_sharing():
    return _cntk_py.enable_forward_values_sharing()
enable_forward_values_sharing = _cntk_py.enable_forward_values_sharing

def disable_forward_values_sharing():
    return _cntk_py.disable_forward_values_sharing()
disable_forward_values_sharing = _cntk_py.disable_forward_values_sharing

def enable_gradient_accumulation_optimization():
    return _cntk_py.enable_gradient_accumulation_optimization()
enable_gradient_accumulation_optimization = _cntk_py.enable_gradient_accumulation_optimization

def disable_gradient_accumulation_optimization():
    return _cntk_py.disable_gradient_accumulation_optimization()
disable_gradient_accumulation_optimization = _cntk_py.disable_gradient_accumulation_optimization

def start_profiler(*args):
    return _cntk_py.start_profiler(*args)
start_profiler = _cntk_py.start_profiler

def enable_profiler():
    return _cntk_py.enable_profiler()
enable_profiler = _cntk_py.enable_profiler

def disable_profiler():
    return _cntk_py.disable_profiler()
disable_profiler = _cntk_py.disable_profiler

def stop_profiler():
    return _cntk_py.stop_profiler()
stop_profiler = _cntk_py.stop_profiler

def are_equivalent(*args):
    return _cntk_py.are_equivalent(*args)
are_equivalent = _cntk_py.are_equivalent

def are_equal(*args):
    return _cntk_py.are_equal(*args)
are_equal = _cntk_py.are_equal

def default_pack_threshold_size_in_bytes():
    return _cntk_py.default_pack_threshold_size_in_bytes()
default_pack_threshold_size_in_bytes = _cntk_py.default_pack_threshold_size_in_bytes

def to_dictionary(dict):
    return _cntk_py.to_dictionary(dict)
to_dictionary = _cntk_py.to_dictionary

def print_built_info():
    return _cntk_py.print_built_info()
print_built_info = _cntk_py.print_built_info

def print_gpu_info(gpusData):
    return _cntk_py.print_gpu_info(gpusData)
print_gpu_info = _cntk_py.print_gpu_info
class TensorBoardFileWriter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TensorBoardFileWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TensorBoardFileWriter, name)
    __repr__ = _swig_repr

    def __init__(self, dir, modelToVisualize=0):
        this = _cntk_py.new_TensorBoardFileWriter(dir, modelToVisualize)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_TensorBoardFileWriter
    __del__ = lambda self: None

    def write_value(self, name, value, step):
        return _cntk_py.TensorBoardFileWriter_write_value(self, name, value, step)

    def write_image(self, name, NDPtr, step):
        return _cntk_py.TensorBoardFileWriter_write_image(self, name, NDPtr, step)

    def flush(self):
        return _cntk_py.TensorBoardFileWriter_flush(self)

    def close(self):
        return _cntk_py.TensorBoardFileWriter_close(self)
TensorBoardFileWriter_swigregister = _cntk_py.TensorBoardFileWriter_swigregister
TensorBoardFileWriter_swigregister(TensorBoardFileWriter)
cvar = _cntk_py.cvar
default_profiler_buffer_size = cvar.default_profiler_buffer_size

class UDFDeserializeCallbackWrapper(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UDFDeserializeCallbackWrapper, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UDFDeserializeCallbackWrapper, name)
    __repr__ = _swig_repr

    def __call__(self, arg0, arg1, arg2):
        return _cntk_py.UDFDeserializeCallbackWrapper___call__(self, arg0, arg1, arg2)
    __swig_destroy__ = _cntk_py.delete_UDFDeserializeCallbackWrapper
    __del__ = lambda self: None

    def __init__(self):
        if self.__class__ == UDFDeserializeCallbackWrapper:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_UDFDeserializeCallbackWrapper(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_UDFDeserializeCallbackWrapper(self)
        return weakref_proxy(self)
UDFDeserializeCallbackWrapper_swigregister = _cntk_py.UDFDeserializeCallbackWrapper_swigregister
UDFDeserializeCallbackWrapper_swigregister(UDFDeserializeCallbackWrapper)


def _register_udf_deserialize_callback(callbackPtr):
    return _cntk_py._register_udf_deserialize_callback(callbackPtr)
_register_udf_deserialize_callback = _cntk_py._register_udf_deserialize_callback

def is_native_user_function_registered(uniqueOpName):
    return _cntk_py.is_native_user_function_registered(uniqueOpName)
is_native_user_function_registered = _cntk_py.is_native_user_function_registered
class SequenceKey(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceKey, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceKey, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_SequenceKey(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["m_sequence"] = _cntk_py.SequenceKey_m_sequence_set
    __swig_getmethods__["m_sequence"] = _cntk_py.SequenceKey_m_sequence_get
    if _newclass:
        m_sequence = _swig_property(_cntk_py.SequenceKey_m_sequence_get, _cntk_py.SequenceKey_m_sequence_set)
    __swig_setmethods__["m_sample"] = _cntk_py.SequenceKey_m_sample_set
    __swig_getmethods__["m_sample"] = _cntk_py.SequenceKey_m_sample_get
    if _newclass:
        m_sample = _swig_property(_cntk_py.SequenceKey_m_sample_get, _cntk_py.SequenceKey_m_sample_set)
    __swig_destroy__ = _cntk_py.delete_SequenceKey
    __del__ = lambda self: None
SequenceKey_swigregister = _cntk_py.SequenceKey_swigregister
SequenceKey_swigregister(SequenceKey)

class SequenceInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_index_in_chunk"] = _cntk_py.SequenceInfo_m_index_in_chunk_set
    __swig_getmethods__["m_index_in_chunk"] = _cntk_py.SequenceInfo_m_index_in_chunk_get
    if _newclass:
        m_index_in_chunk = _swig_property(_cntk_py.SequenceInfo_m_index_in_chunk_get, _cntk_py.SequenceInfo_m_index_in_chunk_set)
    __swig_setmethods__["m_number_of_samples"] = _cntk_py.SequenceInfo_m_number_of_samples_set
    __swig_getmethods__["m_number_of_samples"] = _cntk_py.SequenceInfo_m_number_of_samples_get
    if _newclass:
        m_number_of_samples = _swig_property(_cntk_py.SequenceInfo_m_number_of_samples_get, _cntk_py.SequenceInfo_m_number_of_samples_set)
    __swig_setmethods__["m_chunk_id"] = _cntk_py.SequenceInfo_m_chunk_id_set
    __swig_getmethods__["m_chunk_id"] = _cntk_py.SequenceInfo_m_chunk_id_get
    if _newclass:
        m_chunk_id = _swig_property(_cntk_py.SequenceInfo_m_chunk_id_get, _cntk_py.SequenceInfo_m_chunk_id_set)
    __swig_setmethods__["m_key"] = _cntk_py.SequenceInfo_m_key_set
    __swig_getmethods__["m_key"] = _cntk_py.SequenceInfo_m_key_get
    if _newclass:
        m_key = _swig_property(_cntk_py.SequenceInfo_m_key_get, _cntk_py.SequenceInfo_m_key_set)

    def __init__(self):
        this = _cntk_py.new_SequenceInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_SequenceInfo
    __del__ = lambda self: None
SequenceInfo_swigregister = _cntk_py.SequenceInfo_swigregister
SequenceInfo_swigregister(SequenceInfo)
chunk_id_max = cvar.chunk_id_max
sequence_len_max = cvar.sequence_len_max

class SequenceDataBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceDataBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceDataBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cntk_py.delete_SequenceDataBase
    __del__ = lambda self: None

    def get_sample_shape(self):
        return _cntk_py.SequenceDataBase_get_sample_shape(self)

    def get_data_buffer(self):
        return _cntk_py.SequenceDataBase_get_data_buffer(self)
    __swig_setmethods__["m_number_of_samples"] = _cntk_py.SequenceDataBase_m_number_of_samples_set
    __swig_getmethods__["m_number_of_samples"] = _cntk_py.SequenceDataBase_m_number_of_samples_get
    if _newclass:
        m_number_of_samples = _swig_property(_cntk_py.SequenceDataBase_m_number_of_samples_get, _cntk_py.SequenceDataBase_m_number_of_samples_set)
    __swig_setmethods__["m_element_type"] = _cntk_py.SequenceDataBase_m_element_type_set
    __swig_getmethods__["m_element_type"] = _cntk_py.SequenceDataBase_m_element_type_get
    if _newclass:
        m_element_type = _swig_property(_cntk_py.SequenceDataBase_m_element_type_get, _cntk_py.SequenceDataBase_m_element_type_set)
    __swig_setmethods__["m_is_valid"] = _cntk_py.SequenceDataBase_m_is_valid_set
    __swig_getmethods__["m_is_valid"] = _cntk_py.SequenceDataBase_m_is_valid_get
    if _newclass:
        m_is_valid = _swig_property(_cntk_py.SequenceDataBase_m_is_valid_get, _cntk_py.SequenceDataBase_m_is_valid_set)
    __swig_setmethods__["m_key"] = _cntk_py.SequenceDataBase_m_key_set
    __swig_getmethods__["m_key"] = _cntk_py.SequenceDataBase_m_key_get
    if _newclass:
        m_key = _swig_property(_cntk_py.SequenceDataBase_m_key_get, _cntk_py.SequenceDataBase_m_key_set)
SequenceDataBase_swigregister = _cntk_py.SequenceDataBase_swigregister
SequenceDataBase_swigregister(SequenceDataBase)

class DenseSequenceData(SequenceDataBase):
    __swig_setmethods__ = {}
    for _s in [SequenceDataBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DenseSequenceData, name, value)
    __swig_getmethods__ = {}
    for _s in [SequenceDataBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DenseSequenceData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cntk_py.delete_DenseSequenceData
    __del__ = lambda self: None
DenseSequenceData_swigregister = _cntk_py.DenseSequenceData_swigregister
DenseSequenceData_swigregister(DenseSequenceData)

class SparseSequenceData(SequenceDataBase):
    __swig_setmethods__ = {}
    for _s in [SequenceDataBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparseSequenceData, name, value)
    __swig_getmethods__ = {}
    for _s in [SequenceDataBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SparseSequenceData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["m_indices"] = _cntk_py.SparseSequenceData_m_indices_set
    __swig_getmethods__["m_indices"] = _cntk_py.SparseSequenceData_m_indices_get
    if _newclass:
        m_indices = _swig_property(_cntk_py.SparseSequenceData_m_indices_get, _cntk_py.SparseSequenceData_m_indices_set)
    __swig_setmethods__["m_nnz_counts"] = _cntk_py.SparseSequenceData_m_nnz_counts_set
    __swig_getmethods__["m_nnz_counts"] = _cntk_py.SparseSequenceData_m_nnz_counts_get
    if _newclass:
        m_nnz_counts = _swig_property(_cntk_py.SparseSequenceData_m_nnz_counts_get, _cntk_py.SparseSequenceData_m_nnz_counts_set)
    __swig_setmethods__["m_total_nnz_count"] = _cntk_py.SparseSequenceData_m_total_nnz_count_set
    __swig_getmethods__["m_total_nnz_count"] = _cntk_py.SparseSequenceData_m_total_nnz_count_get
    if _newclass:
        m_total_nnz_count = _swig_property(_cntk_py.SparseSequenceData_m_total_nnz_count_get, _cntk_py.SparseSequenceData_m_total_nnz_count_set)
    __swig_destroy__ = _cntk_py.delete_SparseSequenceData
    __del__ = lambda self: None
SparseSequenceData_swigregister = _cntk_py.SparseSequenceData_swigregister
SparseSequenceData_swigregister(SparseSequenceData)

class Chunk(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Chunk, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Chunk, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_sequence(self, sequenceIndex, result):
        return _cntk_py.Chunk_get_sequence(self, sequenceIndex, result)

    def sequence_infos(self, arg2):
        return _cntk_py.Chunk_sequence_infos(self, arg2)
    __swig_destroy__ = _cntk_py.delete_Chunk
    __del__ = lambda self: None
Chunk_swigregister = _cntk_py.Chunk_swigregister
Chunk_swigregister(Chunk)

class ChunkInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChunkInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChunkInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_id"] = _cntk_py.ChunkInfo_m_id_set
    __swig_getmethods__["m_id"] = _cntk_py.ChunkInfo_m_id_get
    if _newclass:
        m_id = _swig_property(_cntk_py.ChunkInfo_m_id_get, _cntk_py.ChunkInfo_m_id_set)
    __swig_setmethods__["m_number_of_samples"] = _cntk_py.ChunkInfo_m_number_of_samples_set
    __swig_getmethods__["m_number_of_samples"] = _cntk_py.ChunkInfo_m_number_of_samples_get
    if _newclass:
        m_number_of_samples = _swig_property(_cntk_py.ChunkInfo_m_number_of_samples_get, _cntk_py.ChunkInfo_m_number_of_samples_set)
    __swig_setmethods__["m_number_of_sequences"] = _cntk_py.ChunkInfo_m_number_of_sequences_set
    __swig_getmethods__["m_number_of_sequences"] = _cntk_py.ChunkInfo_m_number_of_sequences_get
    if _newclass:
        m_number_of_sequences = _swig_property(_cntk_py.ChunkInfo_m_number_of_sequences_get, _cntk_py.ChunkInfo_m_number_of_sequences_set)

    def __init__(self):
        this = _cntk_py.new_ChunkInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_ChunkInfo
    __del__ = lambda self: None
ChunkInfo_swigregister = _cntk_py.ChunkInfo_swigregister
ChunkInfo_swigregister(ChunkInfo)

class DataDeserializer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataDeserializer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataDeserializer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def stream_infos(self):
        return _cntk_py.DataDeserializer_stream_infos(self)

    def chunk_infos(self):
        return _cntk_py.DataDeserializer_chunk_infos(self)

    def sequence_infos_for_chunk(self, chunkId, result):
        return _cntk_py.DataDeserializer_sequence_infos_for_chunk(self, chunkId, result)

    def get_sequence_info(self, primary, result):
        return _cntk_py.DataDeserializer_get_sequence_info(self, primary, result)

    def get_chunk(self, chunkId):
        return _cntk_py.DataDeserializer_get_chunk(self, chunkId)
    __swig_destroy__ = _cntk_py.delete_DataDeserializer
    __del__ = lambda self: None
DataDeserializer_swigregister = _cntk_py.DataDeserializer_swigregister
DataDeserializer_swigregister(DataDeserializer)

DataType_Unknown = _cntk_py.DataType_Unknown
DataType_Float = _cntk_py.DataType_Float
DataType_Double = _cntk_py.DataType_Double
DataType_UChar = _cntk_py.DataType_UChar

def data_type_name(dataType):
    return _cntk_py.data_type_name(dataType)
data_type_name = _cntk_py.data_type_name

def data_type_size(dataType):
    return _cntk_py.data_type_size(dataType)
data_type_size = _cntk_py.data_type_size
StorageFormat_Dense = _cntk_py.StorageFormat_Dense
StorageFormat_SparseCSC = _cntk_py.StorageFormat_SparseCSC
StorageFormat_SparseBlockCol = _cntk_py.StorageFormat_SparseBlockCol

def is_sparse_storage_format(storageFormat):
    return _cntk_py.is_sparse_storage_format(storageFormat)
is_sparse_storage_format = _cntk_py.is_sparse_storage_format
DeviceKind_CPU = _cntk_py.DeviceKind_CPU
DeviceKind_GPU = _cntk_py.DeviceKind_GPU

def device_kind_name(deviceKind):
    return _cntk_py.device_kind_name(deviceKind)
device_kind_name = _cntk_py.device_kind_name
TraceLevel_Error = _cntk_py.TraceLevel_Error
TraceLevel_Warning = _cntk_py.TraceLevel_Warning
TraceLevel_Info = _cntk_py.TraceLevel_Info
class NDShape(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NDShape, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NDShape, name)
    __repr__ = _swig_repr
    if _newclass:
        unknown = staticmethod(_cntk_py.NDShape_unknown)
    else:
        unknown = _cntk_py.NDShape_unknown

    def __init__(self, *args):
        this = _cntk_py.new_NDShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def is_unknown(self):
        return _cntk_py.NDShape_is_unknown(self)

    def rank(self):
        return _cntk_py.NDShape_rank(self)

    def sub_shape(self, *args):
        return _cntk_py.NDShape_sub_shape(self, *args)

    def has_inferred_dimension(self):
        return _cntk_py.NDShape_has_inferred_dimension(self)

    def has_free_dimension(self):
        return _cntk_py.NDShape_has_free_dimension(self)

    def has_unbound_dimension(self):
        return _cntk_py.NDShape_has_unbound_dimension(self)

    def total_size(self):
        return _cntk_py.NDShape_total_size(self)

    def as_string(self):
        return _cntk_py.NDShape_as_string(self)

    def __getitem__(self, i):
        return _cntk_py.NDShape___getitem__(self, i)

    def dimensions(self):
        return _cntk_py.NDShape_dimensions(self)

    def __hash__(self):
        return _cntk_py.NDShape___hash__(self)
    __swig_destroy__ = _cntk_py.delete_NDShape
    __del__ = lambda self: None
NDShape_swigregister = _cntk_py.NDShape_swigregister
NDShape_swigregister(NDShape)

def eq(first, second):
    return _cntk_py.eq(first, second)
eq = _cntk_py.eq

def NDShape_unknown():
    return _cntk_py.NDShape_unknown()
NDShape_unknown = _cntk_py.NDShape_unknown

class StreamInformation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamInformation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamInformation, name)

    def __init__(self):
        this = _cntk_py.new_StreamInformation()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["m_name"] = _cntk_py.StreamInformation_m_name_set
    __swig_getmethods__["m_name"] = _cntk_py.StreamInformation_m_name_get
    if _newclass:
        m_name = _swig_property(_cntk_py.StreamInformation_m_name_get, _cntk_py.StreamInformation_m_name_set)
    __swig_setmethods__["m_id"] = _cntk_py.StreamInformation_m_id_set
    __swig_getmethods__["m_id"] = _cntk_py.StreamInformation_m_id_get
    if _newclass:
        m_id = _swig_property(_cntk_py.StreamInformation_m_id_get, _cntk_py.StreamInformation_m_id_set)
    __swig_setmethods__["m_storage_format"] = _cntk_py.StreamInformation_m_storage_format_set
    __swig_getmethods__["m_storage_format"] = _cntk_py.StreamInformation_m_storage_format_get
    if _newclass:
        m_storage_format = _swig_property(_cntk_py.StreamInformation_m_storage_format_get, _cntk_py.StreamInformation_m_storage_format_set)
    __swig_setmethods__["m_element_type"] = _cntk_py.StreamInformation_m_element_type_set
    __swig_getmethods__["m_element_type"] = _cntk_py.StreamInformation_m_element_type_get
    if _newclass:
        m_element_type = _swig_property(_cntk_py.StreamInformation_m_element_type_get, _cntk_py.StreamInformation_m_element_type_set)
    __swig_setmethods__["m_sample_layout"] = _cntk_py.StreamInformation_m_sample_layout_set
    __swig_getmethods__["m_sample_layout"] = _cntk_py.StreamInformation_m_sample_layout_get
    if _newclass:
        m_sample_layout = _swig_property(_cntk_py.StreamInformation_m_sample_layout_get, _cntk_py.StreamInformation_m_sample_layout_set)
    __swig_setmethods__["m_defines_mb_size"] = _cntk_py.StreamInformation_m_defines_mb_size_set
    __swig_getmethods__["m_defines_mb_size"] = _cntk_py.StreamInformation_m_defines_mb_size_get
    if _newclass:
        m_defines_mb_size = _swig_property(_cntk_py.StreamInformation_m_defines_mb_size_get, _cntk_py.StreamInformation_m_defines_mb_size_set)

    def as_string(self):
        return _cntk_py.StreamInformation_as_string(self)

    def __str__(self):
        return _cntk_py.StreamInformation___str__(self)

    def __repr__(self):
        return _cntk_py.StreamInformation___repr__(self)

    def __hash__(self):
        return _cntk_py.StreamInformation___hash__(self)
    __swig_destroy__ = _cntk_py.delete_StreamInformation
    __del__ = lambda self: None
StreamInformation_swigregister = _cntk_py.StreamInformation_swigregister
StreamInformation_swigregister(StreamInformation)
sentinel_value_for_auto_select_random_seed = cvar.sentinel_value_for_auto_select_random_seed


def set_checked_mode(enable):
    return _cntk_py.set_checked_mode(enable)
set_checked_mode = _cntk_py.set_checked_mode

def set_trace_level(value):
    return _cntk_py.set_trace_level(value)
set_trace_level = _cntk_py.set_trace_level

def get_trace_level():
    return _cntk_py.get_trace_level()
get_trace_level = _cntk_py.get_trace_level
class MinibatchInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinibatchInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinibatchInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["at_end_of_data"] = _cntk_py.MinibatchInfo_at_end_of_data_set
    __swig_getmethods__["at_end_of_data"] = _cntk_py.MinibatchInfo_at_end_of_data_get
    if _newclass:
        at_end_of_data = _swig_property(_cntk_py.MinibatchInfo_at_end_of_data_get, _cntk_py.MinibatchInfo_at_end_of_data_set)
    __swig_setmethods__["at_end_of_sweep"] = _cntk_py.MinibatchInfo_at_end_of_sweep_set
    __swig_getmethods__["at_end_of_sweep"] = _cntk_py.MinibatchInfo_at_end_of_sweep_get
    if _newclass:
        at_end_of_sweep = _swig_property(_cntk_py.MinibatchInfo_at_end_of_sweep_get, _cntk_py.MinibatchInfo_at_end_of_sweep_set)
    __swig_setmethods__["number_of_samples"] = _cntk_py.MinibatchInfo_number_of_samples_set
    __swig_getmethods__["number_of_samples"] = _cntk_py.MinibatchInfo_number_of_samples_get
    if _newclass:
        number_of_samples = _swig_property(_cntk_py.MinibatchInfo_number_of_samples_get, _cntk_py.MinibatchInfo_number_of_samples_set)
    __swig_setmethods__["training_loss_value"] = _cntk_py.MinibatchInfo_training_loss_value_set
    __swig_getmethods__["training_loss_value"] = _cntk_py.MinibatchInfo_training_loss_value_get
    if _newclass:
        training_loss_value = _swig_property(_cntk_py.MinibatchInfo_training_loss_value_get, _cntk_py.MinibatchInfo_training_loss_value_set)
    __swig_setmethods__["eval_criterion_value"] = _cntk_py.MinibatchInfo_eval_criterion_value_set
    __swig_getmethods__["eval_criterion_value"] = _cntk_py.MinibatchInfo_eval_criterion_value_get
    if _newclass:
        eval_criterion_value = _swig_property(_cntk_py.MinibatchInfo_eval_criterion_value_get, _cntk_py.MinibatchInfo_eval_criterion_value_set)

    def is_empty(self):
        return _cntk_py.MinibatchInfo_is_empty(self)

    def __init__(self):
        this = _cntk_py.new_MinibatchInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_MinibatchInfo
    __del__ = lambda self: None
MinibatchInfo_swigregister = _cntk_py.MinibatchInfo_swigregister
MinibatchInfo_swigregister(MinibatchInfo)

class GPUProperties(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GPUProperties, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GPUProperties, name)
    __repr__ = _swig_repr
    __swig_setmethods__["device_id"] = _cntk_py.GPUProperties_device_id_set
    __swig_getmethods__["device_id"] = _cntk_py.GPUProperties_device_id_get
    if _newclass:
        device_id = _swig_property(_cntk_py.GPUProperties_device_id_get, _cntk_py.GPUProperties_device_id_set)
    __swig_setmethods__["version_major"] = _cntk_py.GPUProperties_version_major_set
    __swig_getmethods__["version_major"] = _cntk_py.GPUProperties_version_major_get
    if _newclass:
        version_major = _swig_property(_cntk_py.GPUProperties_version_major_get, _cntk_py.GPUProperties_version_major_set)
    __swig_setmethods__["version_minor"] = _cntk_py.GPUProperties_version_minor_set
    __swig_getmethods__["version_minor"] = _cntk_py.GPUProperties_version_minor_get
    if _newclass:
        version_minor = _swig_property(_cntk_py.GPUProperties_version_minor_get, _cntk_py.GPUProperties_version_minor_set)
    __swig_setmethods__["cuda_cores"] = _cntk_py.GPUProperties_cuda_cores_set
    __swig_getmethods__["cuda_cores"] = _cntk_py.GPUProperties_cuda_cores_get
    if _newclass:
        cuda_cores = _swig_property(_cntk_py.GPUProperties_cuda_cores_get, _cntk_py.GPUProperties_cuda_cores_set)
    __swig_setmethods__["name"] = _cntk_py.GPUProperties_name_set
    __swig_getmethods__["name"] = _cntk_py.GPUProperties_name_get
    if _newclass:
        name = _swig_property(_cntk_py.GPUProperties_name_get, _cntk_py.GPUProperties_name_set)
    __swig_setmethods__["total_memory"] = _cntk_py.GPUProperties_total_memory_set
    __swig_getmethods__["total_memory"] = _cntk_py.GPUProperties_total_memory_get
    if _newclass:
        total_memory = _swig_property(_cntk_py.GPUProperties_total_memory_get, _cntk_py.GPUProperties_total_memory_set)

    def __init__(self):
        this = _cntk_py.new_GPUProperties()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_GPUProperties
    __del__ = lambda self: None
GPUProperties_swigregister = _cntk_py.GPUProperties_swigregister
GPUProperties_swigregister(GPUProperties)

class DeviceDescriptor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeviceDescriptor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DeviceDescriptor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def id(self):
        return _cntk_py.DeviceDescriptor_id(self)

    def type(self):
        return _cntk_py.DeviceDescriptor_type(self)

    def is_locked(self):
        return _cntk_py.DeviceDescriptor_is_locked(self)
    if _newclass:
        cpu_device = staticmethod(_cntk_py.DeviceDescriptor_cpu_device)
    else:
        cpu_device = _cntk_py.DeviceDescriptor_cpu_device
    if _newclass:
        gpu_device = staticmethod(_cntk_py.DeviceDescriptor_gpu_device)
    else:
        gpu_device = _cntk_py.DeviceDescriptor_gpu_device
    if _newclass:
        use_default_device = staticmethod(_cntk_py.DeviceDescriptor_use_default_device)
    else:
        use_default_device = _cntk_py.DeviceDescriptor_use_default_device
    if _newclass:
        try_set_default_device = staticmethod(_cntk_py.DeviceDescriptor_try_set_default_device)
    else:
        try_set_default_device = _cntk_py.DeviceDescriptor_try_set_default_device
    if _newclass:
        get_gpu_properties = staticmethod(_cntk_py.DeviceDescriptor_get_gpu_properties)
    else:
        get_gpu_properties = _cntk_py.DeviceDescriptor_get_gpu_properties
    if _newclass:
        set_excluded_devices = staticmethod(_cntk_py.DeviceDescriptor_set_excluded_devices)
    else:
        set_excluded_devices = _cntk_py.DeviceDescriptor_set_excluded_devices
    if _newclass:
        all_devices = staticmethod(_cntk_py.DeviceDescriptor_all_devices)
    else:
        all_devices = _cntk_py.DeviceDescriptor_all_devices

    def as_string(self):
        return _cntk_py.DeviceDescriptor_as_string(self)

    def __str__(self):
        return _cntk_py.DeviceDescriptor___str__(self)

    def __repr__(self):
        return _cntk_py.DeviceDescriptor___repr__(self)
    __swig_destroy__ = _cntk_py.delete_DeviceDescriptor
    __del__ = lambda self: None
DeviceDescriptor_swigregister = _cntk_py.DeviceDescriptor_swigregister
DeviceDescriptor_swigregister(DeviceDescriptor)

def DeviceDescriptor_eq(first, second):
    return _cntk_py.DeviceDescriptor_eq(first, second)
DeviceDescriptor_eq = _cntk_py.DeviceDescriptor_eq

def DeviceDescriptor_cpu_device():
    return _cntk_py.DeviceDescriptor_cpu_device()
DeviceDescriptor_cpu_device = _cntk_py.DeviceDescriptor_cpu_device

def DeviceDescriptor_gpu_device(deviceId):
    return _cntk_py.DeviceDescriptor_gpu_device(deviceId)
DeviceDescriptor_gpu_device = _cntk_py.DeviceDescriptor_gpu_device

def DeviceDescriptor_use_default_device():
    return _cntk_py.DeviceDescriptor_use_default_device()
DeviceDescriptor_use_default_device = _cntk_py.DeviceDescriptor_use_default_device

def DeviceDescriptor_try_set_default_device(newDefaultDevice, acquireDeviceLock=False):
    return _cntk_py.DeviceDescriptor_try_set_default_device(newDefaultDevice, acquireDeviceLock)
DeviceDescriptor_try_set_default_device = _cntk_py.DeviceDescriptor_try_set_default_device

def DeviceDescriptor_get_gpu_properties(device):
    return _cntk_py.DeviceDescriptor_get_gpu_properties(device)
DeviceDescriptor_get_gpu_properties = _cntk_py.DeviceDescriptor_get_gpu_properties

def DeviceDescriptor_set_excluded_devices(excluded):
    return _cntk_py.DeviceDescriptor_set_excluded_devices(excluded)
DeviceDescriptor_set_excluded_devices = _cntk_py.DeviceDescriptor_set_excluded_devices

def DeviceDescriptor_all_devices():
    return _cntk_py.DeviceDescriptor_all_devices()
DeviceDescriptor_all_devices = _cntk_py.DeviceDescriptor_all_devices

class IDictionarySerializable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDictionarySerializable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IDictionarySerializable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def serialize(self):
        return _cntk_py.IDictionarySerializable_serialize(self)

    def current_version(self):
        return _cntk_py.IDictionarySerializable_current_version(self)
    __swig_destroy__ = _cntk_py.delete_IDictionarySerializable
    __del__ = lambda self: None
IDictionarySerializable_swigregister = _cntk_py.IDictionarySerializable_swigregister
IDictionarySerializable_swigregister(IDictionarySerializable)

class NDArrayView(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NDArrayView, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NDArrayView, name)
    __swig_destroy__ = _cntk_py.delete_NDArrayView
    __del__ = lambda self: None

    def device(self):
        return _cntk_py.NDArrayView_device(self)

    def get_data_type(self):
        return _cntk_py.NDArrayView_get_data_type(self)

    def get_storage_format(self):
        return _cntk_py.NDArrayView_get_storage_format(self)

    def shape(self):
        return _cntk_py.NDArrayView_shape(self)

    def is_sparse(self):
        return _cntk_py.NDArrayView_is_sparse(self)

    def is_read_only(self):
        return _cntk_py.NDArrayView_is_read_only(self)

    def set_value(self, *args):
        return _cntk_py.NDArrayView_set_value(self, *args)

    def deep_clone(self, *args):
        return _cntk_py.NDArrayView_deep_clone(self, *args)

    def alias(self, readOnly=False):
        return _cntk_py.NDArrayView_alias(self, readOnly)

    def slice_view(self, startOffset, extent, readOnly=False):
        return _cntk_py.NDArrayView_slice_view(self, startOffset, extent, readOnly)

    def as_shape(self, newShape):
        return _cntk_py.NDArrayView_as_shape(self, newShape)

    def copy_from(self, source):
        return _cntk_py.NDArrayView_copy_from(self, source)

    def change_device(self, device):
        return _cntk_py.NDArrayView_change_device(self, device)

    def as_string(self):
        return _cntk_py.NDArrayView_as_string(self)

    def __init__(self, *args):
        this = _cntk_py.new_NDArrayView(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def to_ndarray(self):
        return _cntk_py.NDArrayView_to_ndarray(self)
    if _newclass:
        random_uniform_float = staticmethod(_cntk_py.NDArrayView_random_uniform_float)
    else:
        random_uniform_float = _cntk_py.NDArrayView_random_uniform_float
    if _newclass:
        random_uniform_double = staticmethod(_cntk_py.NDArrayView_random_uniform_double)
    else:
        random_uniform_double = _cntk_py.NDArrayView_random_uniform_double

    def __str__(self):
        return _cntk_py.NDArrayView___str__(self)

    def __repr__(self):
        return _cntk_py.NDArrayView___repr__(self)
NDArrayView_swigregister = _cntk_py.NDArrayView_swigregister
NDArrayView_swigregister(NDArrayView)

def NDArrayViewFloat(*args):
    val = _cntk_py.new_NDArrayViewFloat(*args)
    return val

def NDArrayViewDouble(*args):
    val = _cntk_py.new_NDArrayViewDouble(*args)
    return val

def NDArrayView_random_uniform_float(*args):
    return _cntk_py.NDArrayView_random_uniform_float(*args)
NDArrayView_random_uniform_float = _cntk_py.NDArrayView_random_uniform_float

def NDArrayView_random_uniform_double(*args):
    return _cntk_py.NDArrayView_random_uniform_double(*args)
NDArrayView_random_uniform_double = _cntk_py.NDArrayView_random_uniform_double

MaskKind_Invalid = _cntk_py.MaskKind_Invalid
MaskKind_Valid = _cntk_py.MaskKind_Valid
MaskKind_SequenceBegin = _cntk_py.MaskKind_SequenceBegin
class NDMask(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NDMask, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NDMask, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_NDMask(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_NDMask
    __del__ = lambda self: None

    def invalidate_section(self, sectionOffset, sectionShape):
        return _cntk_py.NDMask_invalidate_section(self, sectionOffset, sectionShape)

    def mark_sequence_begin(self, *args):
        return _cntk_py.NDMask_mark_sequence_begin(self, *args)

    def clear(self):
        return _cntk_py.NDMask_clear(self)

    def masked_count(self):
        return _cntk_py.NDMask_masked_count(self)

    def device(self):
        return _cntk_py.NDMask_device(self)

    def shape(self):
        return _cntk_py.NDMask_shape(self)

    def data_buffer(self):
        return _cntk_py.NDMask_data_buffer(self)

    def deep_clone(self, *args):
        return _cntk_py.NDMask_deep_clone(self, *args)

    def alias(self):
        return _cntk_py.NDMask_alias(self)

    def copy_from(self, source):
        return _cntk_py.NDMask_copy_from(self, source)

    def to_ndarray(self):
        return _cntk_py.NDMask_to_ndarray(self)
NDMask_swigregister = _cntk_py.NDMask_swigregister
NDMask_swigregister(NDMask)

class Axis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Axis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Axis, name)
    if _newclass:
        default_input_variable_dynamic_axes = staticmethod(_cntk_py.Axis_default_input_variable_dynamic_axes)
    else:
        default_input_variable_dynamic_axes = _cntk_py.Axis_default_input_variable_dynamic_axes
    if _newclass:
        unknown_dynamic_axes = staticmethod(_cntk_py.Axis_unknown_dynamic_axes)
    else:
        unknown_dynamic_axes = _cntk_py.Axis_unknown_dynamic_axes

    def is_static_axis(self):
        return _cntk_py.Axis_is_static_axis(self)

    def is_dynamic_axis(self):
        return _cntk_py.Axis_is_dynamic_axis(self)

    def is_batch_axis(self):
        return _cntk_py.Axis_is_batch_axis(self)

    def is_sequence_axis(self):
        return _cntk_py.Axis_is_sequence_axis(self)

    def is_ordered(self):
        return _cntk_py.Axis_is_ordered(self)

    def static_axis_index(self, checked=True):
        return _cntk_py.Axis_static_axis_index(self, checked)
    if _newclass:
        default_dynamic_axis = staticmethod(_cntk_py.Axis_default_dynamic_axis)
    else:
        default_dynamic_axis = _cntk_py.Axis_default_dynamic_axis
    if _newclass:
        operand_sequence_axis = staticmethod(_cntk_py.Axis_operand_sequence_axis)
    else:
        operand_sequence_axis = _cntk_py.Axis_operand_sequence_axis
    if _newclass:
        default_batch_axis = staticmethod(_cntk_py.Axis_default_batch_axis)
    else:
        default_batch_axis = _cntk_py.Axis_default_batch_axis
    if _newclass:
        all_static_axes = staticmethod(_cntk_py.Axis_all_static_axes)
    else:
        all_static_axes = _cntk_py.Axis_all_static_axes
    if _newclass:
        all_axes = staticmethod(_cntk_py.Axis_all_axes)
    else:
        all_axes = _cntk_py.Axis_all_axes
    if _newclass:
        new_unique_dynamic_axis = staticmethod(_cntk_py.Axis_new_unique_dynamic_axis)
    else:
        new_unique_dynamic_axis = _cntk_py.Axis_new_unique_dynamic_axis
    if _newclass:
        end_static_axis = staticmethod(_cntk_py.Axis_end_static_axis)
    else:
        end_static_axis = _cntk_py.Axis_end_static_axis

    def name(self):
        return _cntk_py.Axis_name(self)

    def as_string(self):
        return _cntk_py.Axis_as_string(self)

    def __init__(self, *args):
        this = _cntk_py.new_Axis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, other):
        return _cntk_py.Axis___eq__(self, other)

    def __str__(self):
        return _cntk_py.Axis___str__(self)

    def __repr__(self):
        return _cntk_py.Axis___repr__(self)

    def __hash__(self):
        return _cntk_py.Axis___hash__(self)
    __swig_destroy__ = _cntk_py.delete_Axis
    __del__ = lambda self: None
Axis_swigregister = _cntk_py.Axis_swigregister
Axis_swigregister(Axis)

def Axis_eq(first, second):
    return _cntk_py.Axis_eq(first, second)
Axis_eq = _cntk_py.Axis_eq

def Axis_default_input_variable_dynamic_axes():
    return _cntk_py.Axis_default_input_variable_dynamic_axes()
Axis_default_input_variable_dynamic_axes = _cntk_py.Axis_default_input_variable_dynamic_axes

def Axis_unknown_dynamic_axes():
    return _cntk_py.Axis_unknown_dynamic_axes()
Axis_unknown_dynamic_axes = _cntk_py.Axis_unknown_dynamic_axes

def Axis_default_dynamic_axis():
    return _cntk_py.Axis_default_dynamic_axis()
Axis_default_dynamic_axis = _cntk_py.Axis_default_dynamic_axis

def Axis_operand_sequence_axis():
    return _cntk_py.Axis_operand_sequence_axis()
Axis_operand_sequence_axis = _cntk_py.Axis_operand_sequence_axis

def Axis_default_batch_axis():
    return _cntk_py.Axis_default_batch_axis()
Axis_default_batch_axis = _cntk_py.Axis_default_batch_axis

def Axis_all_static_axes():
    return _cntk_py.Axis_all_static_axes()
Axis_all_static_axes = _cntk_py.Axis_all_static_axes

def Axis_all_axes():
    return _cntk_py.Axis_all_axes()
Axis_all_axes = _cntk_py.Axis_all_axes

def Axis_new_unique_dynamic_axis(axisNamePrefix, isOrderedDynamicAxis=True):
    return _cntk_py.Axis_new_unique_dynamic_axis(axisNamePrefix, isOrderedDynamicAxis)
Axis_new_unique_dynamic_axis = _cntk_py.Axis_new_unique_dynamic_axis

def Axis_end_static_axis():
    return _cntk_py.Axis_end_static_axis()
Axis_end_static_axis = _cntk_py.Axis_end_static_axis

class DictionaryValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DictionaryValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DictionaryValue, name)
    __repr__ = _swig_repr
    Type__none = _cntk_py.DictionaryValue_Type__none
    Type_Bool = _cntk_py.DictionaryValue_Type_Bool
    Type_Int = _cntk_py.DictionaryValue_Type_Int
    Type_SizeT = _cntk_py.DictionaryValue_Type_SizeT
    Type_Float = _cntk_py.DictionaryValue_Type_Float
    Type_Double = _cntk_py.DictionaryValue_Type_Double
    Type_String = _cntk_py.DictionaryValue_Type_String
    Type_NDShape = _cntk_py.DictionaryValue_Type_NDShape
    Type_Axis = _cntk_py.DictionaryValue_Type_Axis
    Type_Vector = _cntk_py.DictionaryValue_Type_Vector
    Type_Dictionary = _cntk_py.DictionaryValue_Type_Dictionary
    Type_NDArrayView = _cntk_py.DictionaryValue_Type_NDArrayView
    Type_TrainingParameterSchedule = _cntk_py.DictionaryValue_Type_TrainingParameterSchedule
    if _newclass:
        type_name = staticmethod(_cntk_py.DictionaryValue_type_name)
    else:
        type_name = _cntk_py.DictionaryValue_type_name
    __swig_destroy__ = _cntk_py.delete_DictionaryValue
    __del__ = lambda self: None

    def has_value(self):
        return _cntk_py.DictionaryValue_has_value(self)

    def value_type(self):
        return _cntk_py.DictionaryValue_value_type(self)

    def __eq__(self, other):
        return _cntk_py.DictionaryValue___eq__(self, other)

    def __ne__(self, other):
        return _cntk_py.DictionaryValue___ne__(self, other)

    def save(self, filename):
        return _cntk_py.DictionaryValue_save(self, filename)
    if _newclass:
        load = staticmethod(_cntk_py.DictionaryValue_load)
    else:
        load = _cntk_py.DictionaryValue_load

    def __init__(self, *args):
        this = _cntk_py.new_DictionaryValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
DictionaryValue_swigregister = _cntk_py.DictionaryValue_swigregister
DictionaryValue_swigregister(DictionaryValue)

def DictionaryValue_type_name(type):
    return _cntk_py.DictionaryValue_type_name(type)
DictionaryValue_type_name = _cntk_py.DictionaryValue_type_name

def DictionaryValue_load(filename):
    return _cntk_py.DictionaryValue_load(filename)
DictionaryValue_load = _cntk_py.DictionaryValue_load

def DictionaryValueFromDict(value):
    val = _cntk_py.new_DictionaryValueFromDict(value)
    return val

def DictionaryValueFromNDArrayView(value):
    val = _cntk_py.new_DictionaryValueFromNDArrayView(value)
    return val

def DictionaryValueFromTrainingDoubleParameterSchedule(value):
    val = _cntk_py.new_DictionaryValueFromTrainingDoubleParameterSchedule(value)
    return val

class Dictionary(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dictionary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dictionary, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _cntk_py.delete_Dictionary
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _cntk_py.new_Dictionary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def contains(self, *args):
        return _cntk_py.Dictionary_contains(self, *args)

    def add(self, *args):
        return _cntk_py.Dictionary_add(self, *args)

    def __eq__(self, other):
        return _cntk_py.Dictionary___eq__(self, other)

    def __ne__(self, other):
        return _cntk_py.Dictionary___ne__(self, other)

    def begin(self):
        return _cntk_py.Dictionary_begin(self)

    def cbegin(self):
        return _cntk_py.Dictionary_cbegin(self)

    def end(self):
        return _cntk_py.Dictionary_end(self)

    def cend(self):
        return _cntk_py.Dictionary_cend(self)

    def size(self):
        return _cntk_py.Dictionary_size(self)

    def save(self, filename):
        return _cntk_py.Dictionary_save(self, filename)
    if _newclass:
        load = staticmethod(_cntk_py.Dictionary_load)
    else:
        load = _cntk_py.Dictionary_load

    def __getitem__(self, key):
        return _cntk_py.Dictionary___getitem__(self, key)

    def __setitem__(self, key, value):
        return _cntk_py.Dictionary___setitem__(self, key, value)

    def keys(self):
        return _cntk_py.Dictionary_keys(self)
Dictionary_swigregister = _cntk_py.Dictionary_swigregister
Dictionary_swigregister(Dictionary)

def Dictionary_load(filename):
    return _cntk_py.Dictionary_load(filename)
Dictionary_load = _cntk_py.Dictionary_load

VariableKind_Input = _cntk_py.VariableKind_Input
VariableKind_Output = _cntk_py.VariableKind_Output
VariableKind_Parameter = _cntk_py.VariableKind_Parameter
VariableKind_Constant = _cntk_py.VariableKind_Constant
VariableKind_Placeholder = _cntk_py.VariableKind_Placeholder

def variable_kind_name(variableKind):
    return _cntk_py.variable_kind_name(variableKind)
variable_kind_name = _cntk_py.variable_kind_name

def generate_uid(*args):
    return _cntk_py.generate_uid(*args)
generate_uid = _cntk_py.generate_uid
class Variable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)

    def shape(self):
        return _cntk_py.Variable_shape(self)

    def dynamic_axes(self):
        return tuple(reversed(_cntk_py.Variable_dynamic_axes(self)))



    def kind(self):
        return _cntk_py.Variable_kind(self)

    def is_sparse(self):
        return _cntk_py.Variable_is_sparse(self)

    def is_input(self):
        return _cntk_py.Variable_is_input(self)

    def is_output(self):
        return _cntk_py.Variable_is_output(self)

    def is_parameter(self):
        return _cntk_py.Variable_is_parameter(self)

    def is_constant(self):
        return _cntk_py.Variable_is_constant(self)

    def is_placeholder(self):
        return _cntk_py.Variable_is_placeholder(self)

    def name(self):
        return _cntk_py.Variable_name(self)

    def uid(self):
        return _cntk_py.Variable_uid(self)

    def owner(self):
        return _cntk_py.Variable_owner(self)

    def get_data_type(self):
        return _cntk_py.Variable_get_data_type(self)

    def needs_gradient(self):
        return _cntk_py.Variable_needs_gradient(self)

    def as_string(self):
        return _cntk_py.Variable_as_string(self)

    def current_value_time_stamp(self):
        return _cntk_py.Variable_current_value_time_stamp(self)

    def __init__(self, *args):
        this = _cntk_py.new_Variable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        return _cntk_py.Variable___str__(self)

    def __repr__(self):
        return _cntk_py.Variable___repr__(self)

    def __hash__(self):
        return _cntk_py.Variable___hash__(self)
    __swig_destroy__ = _cntk_py.delete_Variable
    __del__ = lambda self: None
Variable_swigregister = _cntk_py.Variable_swigregister
Variable_swigregister(Variable)

def Variable_eq(first, second):
    return _cntk_py.Variable_eq(first, second)
Variable_eq = _cntk_py.Variable_eq


def __ne__(*args):
    return _cntk_py.__ne__(*args)
__ne__ = _cntk_py.__ne__

def placeholder_variable(*args):
    return _cntk_py.placeholder_variable(*args)
placeholder_variable = _cntk_py.placeholder_variable

def input_variable(*args):
    return _cntk_py.input_variable(*args)
input_variable = _cntk_py.input_variable

def output_variable(*args):
    return _cntk_py.output_variable(*args)
output_variable = _cntk_py.output_variable

def constant_initializer(value=0.0):
    return _cntk_py.constant_initializer(value)
constant_initializer = _cntk_py.constant_initializer

def uniform_initializer(*args):
    return _cntk_py.uniform_initializer(*args)
uniform_initializer = _cntk_py.uniform_initializer

def normal_initializer(*args):
    return _cntk_py.normal_initializer(*args)
normal_initializer = _cntk_py.normal_initializer

def xavier_initializer(*args):
    return _cntk_py.xavier_initializer(*args)
xavier_initializer = _cntk_py.xavier_initializer

def glorot_uniform_initializer(*args):
    return _cntk_py.glorot_uniform_initializer(*args)
glorot_uniform_initializer = _cntk_py.glorot_uniform_initializer

def glorot_normal_initializer(*args):
    return _cntk_py.glorot_normal_initializer(*args)
glorot_normal_initializer = _cntk_py.glorot_normal_initializer

def he_uniform_initializer(*args):
    return _cntk_py.he_uniform_initializer(*args)
he_uniform_initializer = _cntk_py.he_uniform_initializer

def he_normal_initializer(*args):
    return _cntk_py.he_normal_initializer(*args)
he_normal_initializer = _cntk_py.he_normal_initializer

def bilinear_initializer(kernelWidth, kernelHeight):
    return _cntk_py.bilinear_initializer(kernelWidth, kernelHeight)
bilinear_initializer = _cntk_py.bilinear_initializer

def random_initializer_with_rank(initializer, outputRank, filterRank):
    return _cntk_py.random_initializer_with_rank(initializer, outputRank, filterRank)
random_initializer_with_rank = _cntk_py.random_initializer_with_rank

def truncated_normal_initializer(*args):
    return _cntk_py.truncated_normal_initializer(*args)
truncated_normal_initializer = _cntk_py.truncated_normal_initializer
class Parameter(Variable):
    __swig_setmethods__ = {}
    for _s in [Variable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parameter, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Parameter, name)

    def __init__(self, *args):
        this = _cntk_py.new_Parameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def value(self):
        return _cntk_py.Parameter_value(self)

    def set_value(self, value):
        return _cntk_py.Parameter_set_value(self, value)

    def record_value_update(self):
        return _cntk_py.Parameter_record_value_update(self)

    def __str__(self):
        return _cntk_py.Parameter___str__(self)

    def __repr__(self):
        return _cntk_py.Parameter___repr__(self)

    def __hash__(self):
        return _cntk_py.Parameter___hash__(self)
    __swig_destroy__ = _cntk_py.delete_Parameter
    __del__ = lambda self: None
Parameter_swigregister = _cntk_py.Parameter_swigregister
Parameter_swigregister(Parameter)
sentinel_value_for_infer_param_init_rank = cvar.sentinel_value_for_infer_param_init_rank
default_param_init_scale = cvar.default_param_init_scale
default_param_init_output_rank = cvar.default_param_init_output_rank
default_param_init_filter_rank = cvar.default_param_init_filter_rank

def ParameterFloat(*args):
    val = _cntk_py.new_ParameterFloat(*args)
    return val

def ParameterDouble(*args):
    val = _cntk_py.new_ParameterDouble(*args)
    return val

class Constant(Variable):
    __swig_setmethods__ = {}
    for _s in [Variable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Constant, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Constant, name)

    def clone_as(self, dataType):
        return _cntk_py.Constant_clone_as(self, dataType)
    if _newclass:
        scalar = staticmethod(_cntk_py.Constant_scalar)
    else:
        scalar = _cntk_py.Constant_scalar

    def __init__(self, *args):
        this = _cntk_py.new_Constant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def value(self):
        return _cntk_py.Constant_value(self)

    def set_value(self, value):
        return _cntk_py.Constant_set_value(self, value)

    def record_value_update(self):
        return _cntk_py.Constant_record_value_update(self)

    def __str__(self):
        return _cntk_py.Constant___str__(self)

    def __repr__(self):
        return _cntk_py.Constant___repr__(self)

    def __hash__(self):
        return _cntk_py.Constant___hash__(self)
    __swig_destroy__ = _cntk_py.delete_Constant
    __del__ = lambda self: None
Constant_swigregister = _cntk_py.Constant_swigregister
Constant_swigregister(Constant)

def Constant_scalar(*args):
    return _cntk_py.Constant_scalar(*args)
Constant_scalar = _cntk_py.Constant_scalar

def ConstantFloat(*args):
    val = _cntk_py.new_ConstantFloat(*args)
    return val

def ConstantDouble(*args):
    val = _cntk_py.new_ConstantDouble(*args)
    return val

class Value(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Value, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Value, name)
    one_hot_skip = _cntk_py.Value_one_hot_skip

    def __init__(self, *args):
        this = _cntk_py.new_Value(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        create = staticmethod(_cntk_py.Value_create)
    else:
        create = _cntk_py.Value_create
    __swig_destroy__ = _cntk_py.delete_Value
    __del__ = lambda self: None

    def device(self):
        return _cntk_py.Value_device(self)

    def get_data_type(self):
        return _cntk_py.Value_get_data_type(self)

    def get_storage_format(self):
        return _cntk_py.Value_get_storage_format(self)

    def shape(self):
        return _cntk_py.Value_shape(self)

    def is_sparse(self):
        return _cntk_py.Value_is_sparse(self)

    def is_read_only(self):
        return _cntk_py.Value_is_read_only(self)

    def masked_count(self):
        return _cntk_py.Value_masked_count(self)

    def data(self):
        return _cntk_py.Value_data(self)

    def mask(self):
        return _cntk_py.Value_mask(self)

    def deep_clone(self, *args):
        return _cntk_py.Value_deep_clone(self, *args)

    def alias(self, readOnly=False):
        return _cntk_py.Value_alias(self, readOnly)

    def copy_from(self, source):
        return _cntk_py.Value_copy_from(self, source)

    def erase(self):
        return _cntk_py.Value_erase(self)

    def unpack_variable_value(self, *args):
        return _cntk_py.Value_unpack_variable_value(self, *args)

    def copy_variable_value_to(self, outputVariable, sequences):
        return _cntk_py.Value_copy_variable_value_to(self, outputVariable, sequences)

    def is_valid(self):
        return _cntk_py.Value_is_valid(self)

    def as_string(self):
        return _cntk_py.Value_as_string(self)
    if _newclass:
        create_dense_float = staticmethod(_cntk_py.Value_create_dense_float)
    else:
        create_dense_float = _cntk_py.Value_create_dense_float
    if _newclass:
        create_dense_double = staticmethod(_cntk_py.Value_create_dense_double)
    else:
        create_dense_double = _cntk_py.Value_create_dense_double
    if _newclass:
        create_one_hot_float = staticmethod(_cntk_py.Value_create_one_hot_float)
    else:
        create_one_hot_float = _cntk_py.Value_create_one_hot_float
    if _newclass:
        create_one_hot_double = staticmethod(_cntk_py.Value_create_one_hot_double)
    else:
        create_one_hot_double = _cntk_py.Value_create_one_hot_double
    if _newclass:
        create_batch_float = staticmethod(_cntk_py.Value_create_batch_float)
    else:
        create_batch_float = _cntk_py.Value_create_batch_float
    if _newclass:
        create_batch_double = staticmethod(_cntk_py.Value_create_batch_double)
    else:
        create_batch_double = _cntk_py.Value_create_batch_double
    if _newclass:
        create_sequence_float = staticmethod(_cntk_py.Value_create_sequence_float)
    else:
        create_sequence_float = _cntk_py.Value_create_sequence_float
    if _newclass:
        create_sequence_double = staticmethod(_cntk_py.Value_create_sequence_double)
    else:
        create_sequence_double = _cntk_py.Value_create_sequence_double

    def copy_variable_value_to_float(self, *args):
        return _cntk_py.Value_copy_variable_value_to_float(self, *args)

    def copy_variable_value_to_double(self, *args):
        return _cntk_py.Value_copy_variable_value_to_double(self, *args)

    def __str__(self):
        return _cntk_py.Value___str__(self)

    def __repr__(self):
        return _cntk_py.Value___repr__(self)
Value_swigregister = _cntk_py.Value_swigregister
Value_swigregister(Value)

def Value_create(*args):
    return _cntk_py.Value_create(*args)
Value_create = _cntk_py.Value_create

def Value_create_dense_float(*args):
    return _cntk_py.Value_create_dense_float(*args)
Value_create_dense_float = _cntk_py.Value_create_dense_float

def Value_create_dense_double(*args):
    return _cntk_py.Value_create_dense_double(*args)
Value_create_dense_double = _cntk_py.Value_create_dense_double

def Value_create_one_hot_float(*args):
    return _cntk_py.Value_create_one_hot_float(*args)
Value_create_one_hot_float = _cntk_py.Value_create_one_hot_float

def Value_create_one_hot_double(*args):
    return _cntk_py.Value_create_one_hot_double(*args)
Value_create_one_hot_double = _cntk_py.Value_create_one_hot_double

def Value_create_batch_float(*args):
    return _cntk_py.Value_create_batch_float(*args)
Value_create_batch_float = _cntk_py.Value_create_batch_float

def Value_create_batch_double(*args):
    return _cntk_py.Value_create_batch_double(*args)
Value_create_batch_double = _cntk_py.Value_create_batch_double

def Value_create_sequence_float(*args):
    return _cntk_py.Value_create_sequence_float(*args)
Value_create_sequence_float = _cntk_py.Value_create_sequence_float

def Value_create_sequence_double(*args):
    return _cntk_py.Value_create_sequence_double(*args)
Value_create_sequence_double = _cntk_py.Value_create_sequence_double

class BackPropState(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BackPropState, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BackPropState, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_BackPropState(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_BackPropState
    __del__ = lambda self: None

    def function(self):
        return _cntk_py.BackPropState_function(self)

    def device(self):
        return _cntk_py.BackPropState_device(self)

    def saved_forward_prop_values(self):
        return _cntk_py.BackPropState_saved_forward_prop_values(self)
BackPropState_swigregister = _cntk_py.BackPropState_swigregister
BackPropState_swigregister(BackPropState)

ParameterCloningMethod_Share = _cntk_py.ParameterCloningMethod_Share
ParameterCloningMethod_Clone = _cntk_py.ParameterCloningMethod_Clone
ParameterCloningMethod_Freeze = _cntk_py.ParameterCloningMethod_Freeze
ParameterCloningMethod_Invalid = _cntk_py.ParameterCloningMethod_Invalid
class Function(IDictionarySerializable):
    __swig_setmethods__ = {}
    for _s in [IDictionarySerializable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Function, name, value)
    __swig_getmethods__ = {}
    for _s in [IDictionarySerializable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Function, name)

    def _backward(self, state, rootGradientValues, backPropagatedGradientValuesForInputs):
        return _cntk_py.Function__backward(self, state, rootGradientValues, backPropagatedGradientValuesForInputs)

    def _forward(self, *args):
        return _cntk_py.Function__forward(self, *args)

    def _infer_outputs(self, outputs):
        return _cntk_py.Function__infer_outputs(self, outputs)

    def module_name(self):
        return _cntk_py.Function_module_name(self)

    def deserialize_method_name(self):
        return _cntk_py.Function_deserialize_method_name(self)
    __swig_destroy__ = _cntk_py.delete_Function
    __del__ = lambda self: None

    def op_name(self):
        return _cntk_py.Function_op_name(self)

    def current_version(self):
        return _cntk_py.Function_current_version(self)

    def _serialize_impl(self):
        return _cntk_py.Function__serialize_impl(self)

    def gradients(self, *args):
        return _cntk_py.Function_gradients(self, *args)

    def evaluate(self, *args):
        return _cntk_py.Function_evaluate(self, *args)

    def clone(self, *args):
        return _cntk_py.Function_clone(self, *args)
    if _newclass:
        _deserialize = staticmethod(_cntk_py.Function__deserialize)
    else:
        _deserialize = _cntk_py.Function__deserialize

    def name(self):
        return _cntk_py.Function_name(self)

    def set_name(self, name):
        return _cntk_py.Function_set_name(self, name)

    def uid(self):
        return _cntk_py.Function_uid(self)

    def root_function(self):
        return _cntk_py.Function_root_function(self)

    def is_composite(self):
        return _cntk_py.Function_is_composite(self)

    def is_primitive(self):
        return _cntk_py.Function_is_primitive(self)

    def is_block(self):
        return _cntk_py.Function_is_block(self)

    def block_root(self):
        return _cntk_py.Function_block_root(self)

    def block_arguments_mapping(self):
        return _cntk_py.Function_block_arguments_mapping(self)

    def inputs(self, pythonOperandOrder=False):
        return _cntk_py.Function_inputs(self, pythonOperandOrder)

    def output(self):
        return _cntk_py.Function_output(self)

    def outputs(self):
        return _cntk_py.Function_outputs(self)

    def arguments(self, rowMajor=False):
        return _cntk_py.Function_arguments(self, rowMajor)

    def parameters(self):
        return _cntk_py.Function_parameters(self)

    def constants(self):
        return _cntk_py.Function_constants(self)

    def placeholders(self):
        return _cntk_py.Function_placeholders(self)

    def find_by_name(self, name, nestedSearchInsideBlockFunction=False):
        return _cntk_py.Function_find_by_name(self, name, nestedSearchInsideBlockFunction)

    def find_all_with_name(self, name, nestedSearchInsideBlockFunction=False):
        return _cntk_py.Function_find_all_with_name(self, name, nestedSearchInsideBlockFunction)

    def attributes(self):
        return _cntk_py.Function_attributes(self)

    def replace_placeholders(self, placeholderReplacements):
        return _cntk_py.Function_replace_placeholders(self, placeholderReplacements)

    def replace_placeholder(self, placeholderReplacement):
        return _cntk_py.Function_replace_placeholder(self, placeholderReplacement)

    def save(self, *args):
        return _cntk_py.Function_save(self, *args)

    def restore(self, filepath):
        return _cntk_py.Function_restore(self, filepath)
    if _newclass:
        load_from_buffer = staticmethod(_cntk_py.Function_load_from_buffer)
    else:
        load_from_buffer = _cntk_py.Function_load_from_buffer
    if _newclass:
        load = staticmethod(_cntk_py.Function_load)
    else:
        load = _cntk_py.Function_load

    def as_string(self, doNotInferOutputs=True):
        return _cntk_py.Function_as_string(self, doNotInferOutputs)

    def set_attribute(self, name, value):
        return _cntk_py.Function_set_attribute(self, name, value)
    max_num_outputs = _cntk_py.Function_max_num_outputs
    if _newclass:
        register_native_user_function = staticmethod(_cntk_py.Function_register_native_user_function)
    else:
        register_native_user_function = _cntk_py.Function_register_native_user_function
    if _newclass:
        native_user_function = staticmethod(_cntk_py.Function_native_user_function)
    else:
        native_user_function = _cntk_py.Function_native_user_function

    def __init__(self, *args):
        if self.__class__ == Function:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_Function(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def restore_from_checkpoint(self, dictionary):
        return _cntk_py.Function_restore_from_checkpoint(self, dictionary)

    def set_native(self, native):
        return _cntk_py.Function_set_native(self, native)

    def __str__(self):
        return _cntk_py.Function___str__(self)

    def __repr__(self):
        return _cntk_py.Function___repr__(self)
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_Function(self)
        return weakref_proxy(self)
Function_swigregister = _cntk_py.Function_swigregister
Function_swigregister(Function)

def Function__deserialize(*args):
    return _cntk_py.Function__deserialize(*args)
Function__deserialize = _cntk_py.Function__deserialize

def Function_load_from_buffer(*args):
    return _cntk_py.Function_load_from_buffer(*args)
Function_load_from_buffer = _cntk_py.Function_load_from_buffer

def Function_load(*args):
    return _cntk_py.Function_load(*args)
Function_load = _cntk_py.Function_load

def Function_register_native_user_function(uniqueOpId, moduleName, factoryMethodName):
    return _cntk_py.Function_register_native_user_function(uniqueOpId, moduleName, factoryMethodName)
Function_register_native_user_function = _cntk_py.Function_register_native_user_function

def Function_native_user_function(*args):
    return _cntk_py.Function_native_user_function(*args)
Function_native_user_function = _cntk_py.Function_native_user_function


def negate(*args):
    return _cntk_py.negate(*args)
negate = _cntk_py.negate

def sigmoid(*args):
    return _cntk_py.sigmoid(*args)
sigmoid = _cntk_py.sigmoid

def tanh(*args):
    return _cntk_py.tanh(*args)
tanh = _cntk_py.tanh

def asin(*args):
    return _cntk_py.asin(*args)
asin = _cntk_py.asin

def sin(*args):
    return _cntk_py.sin(*args)
sin = _cntk_py.sin

def acos(*args):
    return _cntk_py.acos(*args)
acos = _cntk_py.acos

def cos(*args):
    return _cntk_py.cos(*args)
cos = _cntk_py.cos

def cosh(*args):
    return _cntk_py.cosh(*args)
cosh = _cntk_py.cosh

def sinh(*args):
    return _cntk_py.sinh(*args)
sinh = _cntk_py.sinh

def re_lu(*args):
    return _cntk_py.re_lu(*args)
re_lu = _cntk_py.re_lu

def exp(*args):
    return _cntk_py.exp(*args)
exp = _cntk_py.exp

def log(*args):
    return _cntk_py.log(*args)
log = _cntk_py.log

def square(*args):
    return _cntk_py.square(*args)
square = _cntk_py.square

def sqrt(*args):
    return _cntk_py.sqrt(*args)
sqrt = _cntk_py.sqrt

def round(*args):
    return _cntk_py.round(*args)
round = _cntk_py.round

def floor(*args):
    return _cntk_py.floor(*args)
floor = _cntk_py.floor

def ceil(*args):
    return _cntk_py.ceil(*args)
ceil = _cntk_py.ceil

def abs(*args):
    return _cntk_py.abs(*args)
abs = _cntk_py.abs

def reciprocal(*args):
    return _cntk_py.reciprocal(*args)
reciprocal = _cntk_py.reciprocal

def softmax(*args):
    return _cntk_py.softmax(*args)
softmax = _cntk_py.softmax

def hardmax(*args):
    return _cntk_py.hardmax(*args)
hardmax = _cntk_py.hardmax

def transpose_axes(*args):
    return _cntk_py.transpose_axes(*args)
transpose_axes = _cntk_py.transpose_axes

def transpose(*args):
    return _cntk_py.transpose(*args)
transpose = _cntk_py.transpose

def slice(*args):
    return _cntk_py.slice(*args)
slice = _cntk_py.slice

def to_batch(*args):
    return _cntk_py.to_batch(*args)
to_batch = _cntk_py.to_batch

def unpack_batch(operand, name):
    return _cntk_py.unpack_batch(operand, name)
unpack_batch = _cntk_py.unpack_batch
PaddingMode_CONSTANTPAD = _cntk_py.PaddingMode_CONSTANTPAD
PaddingMode_REFLECTPAD = _cntk_py.PaddingMode_REFLECTPAD
PaddingMode_SYMMETRICPAD = _cntk_py.PaddingMode_SYMMETRICPAD

def pad(*args):
    return _cntk_py.pad(*args)
pad = _cntk_py.pad

def random_sample(*args):
    return _cntk_py.random_sample(*args)
random_sample = _cntk_py.random_sample

def random_sample_inclusion_frequency(*args):
    return _cntk_py.random_sample_inclusion_frequency(*args)
random_sample_inclusion_frequency = _cntk_py.random_sample_inclusion_frequency

def dropout(*args):
    return _cntk_py.dropout(*args)
dropout = _cntk_py.dropout

def uniform_random(*args):
    return _cntk_py.uniform_random(*args)
uniform_random = _cntk_py.uniform_random

def uniform_random_like(*args):
    return _cntk_py.uniform_random_like(*args)
uniform_random_like = _cntk_py.uniform_random_like

def normal_random(*args):
    return _cntk_py.normal_random(*args)
normal_random = _cntk_py.normal_random

def normal_random_like(*args):
    return _cntk_py.normal_random_like(*args)
normal_random_like = _cntk_py.normal_random_like

def gumbel_random(*args):
    return _cntk_py.gumbel_random(*args)
gumbel_random = _cntk_py.gumbel_random

def gumbel_random_like(*args):
    return _cntk_py.gumbel_random_like(*args)
gumbel_random_like = _cntk_py.gumbel_random_like

def bernoulli_random(*args):
    return _cntk_py.bernoulli_random(*args)
bernoulli_random = _cntk_py.bernoulli_random

def bernoulli_random_like(*args):
    return _cntk_py.bernoulli_random_like(*args)
bernoulli_random_like = _cntk_py.bernoulli_random_like

def reshape(*args):
    return _cntk_py.reshape(*args)
reshape = _cntk_py.reshape

def plus(*args):
    return _cntk_py.plus(*args)
plus = _cntk_py.plus

def __add__(leftOperand, rightOperand):
    return _cntk_py.__add__(leftOperand, rightOperand)
__add__ = _cntk_py.__add__

def minus(*args):
    return _cntk_py.minus(*args)
minus = _cntk_py.minus

def __sub__(*args):
    return _cntk_py.__sub__(*args)
__sub__ = _cntk_py.__sub__

def log_add_exp(*args):
    return _cntk_py.log_add_exp(*args)
log_add_exp = _cntk_py.log_add_exp

def pow(*args):
    return _cntk_py.pow(*args)
pow = _cntk_py.pow

def element_times(*args):
    return _cntk_py.element_times(*args)
element_times = _cntk_py.element_times

def element_divide(*args):
    return _cntk_py.element_divide(*args)
element_divide = _cntk_py.element_divide

def equal(*args):
    return _cntk_py.equal(*args)
equal = _cntk_py.equal

def not_equal(*args):
    return _cntk_py.not_equal(*args)
not_equal = _cntk_py.not_equal

def less(*args):
    return _cntk_py.less(*args)
less = _cntk_py.less

def less_equal(*args):
    return _cntk_py.less_equal(*args)
less_equal = _cntk_py.less_equal

def greater(*args):
    return _cntk_py.greater(*args)
greater = _cntk_py.greater

def greater_equal(*args):
    return _cntk_py.greater_equal(*args)
greater_equal = _cntk_py.greater_equal
TimesNoInferredInputRank = _cntk_py.TimesNoInferredInputRank
TimesReduceSequenceAxisWithoutInferredInputRank = _cntk_py.TimesReduceSequenceAxisWithoutInferredInputRank

def times(*args):
    return _cntk_py.times(*args)
times = _cntk_py.times

def times_transpose(*args):
    return _cntk_py.times_transpose(*args)
times_transpose = _cntk_py.times_transpose

def cosine_distance(*args):
    return _cntk_py.cosine_distance(*args)
cosine_distance = _cntk_py.cosine_distance

def cosine_distance_with_negative_samples(*args):
    return _cntk_py.cosine_distance_with_negative_samples(*args)
cosine_distance_with_negative_samples = _cntk_py.cosine_distance_with_negative_samples

def binary_cross_entropy(*args):
    return _cntk_py.binary_cross_entropy(*args)
binary_cross_entropy = _cntk_py.binary_cross_entropy

def weighted_binary_cross_entropy(*args):
    return _cntk_py.weighted_binary_cross_entropy(*args)
weighted_binary_cross_entropy = _cntk_py.weighted_binary_cross_entropy

def squared_error(*args):
    return _cntk_py.squared_error(*args)
squared_error = _cntk_py.squared_error

def cross_entropy_with_softmax(*args):
    return _cntk_py.cross_entropy_with_softmax(*args)
cross_entropy_with_softmax = _cntk_py.cross_entropy_with_softmax

def edit_distance_error(*args):
    return _cntk_py.edit_distance_error(*args)
edit_distance_error = _cntk_py.edit_distance_error

def forward_backward(*args):
    return _cntk_py.forward_backward(*args)
forward_backward = _cntk_py.forward_backward

def labels_to_graph(*args):
    return _cntk_py.labels_to_graph(*args)
labels_to_graph = _cntk_py.labels_to_graph

def classification_error(*args):
    return _cntk_py.classification_error(*args)
classification_error = _cntk_py.classification_error

def nce_loss(*args):
    return _cntk_py.nce_loss(*args)
nce_loss = _cntk_py.nce_loss

def lambda_rank(*args):
    return _cntk_py.lambda_rank(*args)
lambda_rank = _cntk_py.lambda_rank

def ndcg_at_1(*args):
    return _cntk_py.ndcg_at_1(*args)
ndcg_at_1 = _cntk_py.ndcg_at_1

def past_value(*args):
    return _cntk_py.past_value(*args)
past_value = _cntk_py.past_value

def future_value(*args):
    return _cntk_py.future_value(*args)
future_value = _cntk_py.future_value

def one_hot_op(*args):
    return _cntk_py.one_hot_op(*args)
one_hot_op = _cntk_py.one_hot_op

def gather_op(*args):
    return _cntk_py.gather_op(*args)
gather_op = _cntk_py.gather_op

def reduce_sum(*args):
    return _cntk_py.reduce_sum(*args)
reduce_sum = _cntk_py.reduce_sum

def reduce_log_sum(*args):
    return _cntk_py.reduce_log_sum(*args)
reduce_log_sum = _cntk_py.reduce_log_sum

def reduce_mean(*args):
    return _cntk_py.reduce_mean(*args)
reduce_mean = _cntk_py.reduce_mean

def reduce_max(*args):
    return _cntk_py.reduce_max(*args)
reduce_max = _cntk_py.reduce_max

def reduce_min(*args):
    return _cntk_py.reduce_min(*args)
reduce_min = _cntk_py.reduce_min

def reduce_prod(*args):
    return _cntk_py.reduce_prod(*args)
reduce_prod = _cntk_py.reduce_prod

def per_dim_mean_variance_normalize(*args):
    return _cntk_py.per_dim_mean_variance_normalize(*args)
per_dim_mean_variance_normalize = _cntk_py.per_dim_mean_variance_normalize

def convolution(*args):
    return _cntk_py.convolution(*args)
convolution = _cntk_py.convolution

def convolution_transpose(*args):
    return _cntk_py.convolution_transpose(*args)
convolution_transpose = _cntk_py.convolution_transpose
PoolingType_Max = _cntk_py.PoolingType_Max
PoolingType_Average = _cntk_py.PoolingType_Average

def roipooling(operand, rois, poolingType, roiOutputShape, spatialScale, name):
    return _cntk_py.roipooling(operand, rois, poolingType, roiOutputShape, spatialScale, name)
roipooling = _cntk_py.roipooling

def pooling(*args):
    return _cntk_py.pooling(*args)
pooling = _cntk_py.pooling

def unpooling(*args):
    return _cntk_py.unpooling(*args)
unpooling = _cntk_py.unpooling

def batch_normalization(*args):
    return _cntk_py.batch_normalization(*args)
batch_normalization = _cntk_py.batch_normalization

def optimized_rnnstack(*args):
    return _cntk_py.optimized_rnnstack(*args)
optimized_rnnstack = _cntk_py.optimized_rnnstack

def clip(*args):
    return _cntk_py.clip(*args)
clip = _cntk_py.clip

def element_select(*args):
    return _cntk_py.element_select(*args)
element_select = _cntk_py.element_select

def splice(*args):
    return _cntk_py.splice(*args)
splice = _cntk_py.splice

def combine(*args):
    return _cntk_py.combine(*args)
combine = _cntk_py.combine

def alias(*args):
    return _cntk_py.alias(*args)
alias = _cntk_py.alias

def as_block(*args):
    return _cntk_py.as_block(*args)
as_block = _cntk_py.as_block

def stop_gradient(*args):
    return _cntk_py.stop_gradient(*args)
stop_gradient = _cntk_py.stop_gradient

def assign(*args):
    return _cntk_py.assign(*args)
assign = _cntk_py.assign

def as_composite(*args):
    return _cntk_py.as_composite(*args)
as_composite = _cntk_py.as_composite

def elu(*args):
    return _cntk_py.elu(*args)
elu = _cntk_py.elu

def selu(*args):
    return _cntk_py.selu(*args)
selu = _cntk_py.selu

def leaky_re_lu(*args):
    return _cntk_py.leaky_re_lu(*args)
leaky_re_lu = _cntk_py.leaky_re_lu

def pre_lu(*args):
    return _cntk_py.pre_lu(*args)
pre_lu = _cntk_py.pre_lu

def softplus(*args):
    return _cntk_py.softplus(*args)
softplus = _cntk_py.softplus

def argmax(*args):
    return _cntk_py.argmax(*args)
argmax = _cntk_py.argmax

def argmin(*args):
    return _cntk_py.argmin(*args)
argmin = _cntk_py.argmin

def to_sequence(*args):
    return _cntk_py.to_sequence(*args)
to_sequence = _cntk_py.to_sequence

def to_sequence_like(*args):
    return _cntk_py.to_sequence_like(*args)
to_sequence_like = _cntk_py.to_sequence_like

def reconcile_dynamic_axes(*args):
    return _cntk_py.reconcile_dynamic_axes(*args)
reconcile_dynamic_axes = _cntk_py.reconcile_dynamic_axes

def is_first(*args):
    return _cntk_py.is_first(*args)
is_first = _cntk_py.is_first

def is_last(*args):
    return _cntk_py.is_last(*args)
is_last = _cntk_py.is_last

def sequence_slice(*args):
    return _cntk_py.sequence_slice(*args)
sequence_slice = _cntk_py.sequence_slice

def sequence_reduce_sum(*args):
    return _cntk_py.sequence_reduce_sum(*args)
sequence_reduce_sum = _cntk_py.sequence_reduce_sum

def sequence_reduce_max(*args):
    return _cntk_py.sequence_reduce_max(*args)
sequence_reduce_max = _cntk_py.sequence_reduce_max

def sequence_softmax(*args):
    return _cntk_py.sequence_softmax(*args)
sequence_softmax = _cntk_py.sequence_softmax

def first(*args):
    return _cntk_py.first(*args)
first = _cntk_py.first

def last(*args):
    return _cntk_py.last(*args)
last = _cntk_py.last

def where(*args):
    return _cntk_py.where(*args)
where = _cntk_py.where

def gather(*args):
    return _cntk_py.gather(*args)
gather = _cntk_py.gather

def scatter(*args):
    return _cntk_py.scatter(*args)
scatter = _cntk_py.scatter

def broadcast_as(*args):
    return _cntk_py.broadcast_as(*args)
broadcast_as = _cntk_py.broadcast_as

def unpack(*args):
    return _cntk_py.unpack(*args)
unpack = _cntk_py.unpack

def momentum_from_time_constant(momTC):
    return _cntk_py.momentum_from_time_constant(momTC)
momentum_from_time_constant = _cntk_py.momentum_from_time_constant

def momentum_as_time_constant_schedule(*args):
    return _cntk_py.momentum_as_time_constant_schedule(*args)
momentum_as_time_constant_schedule = _cntk_py.momentum_as_time_constant_schedule
class AdditionalLearningOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AdditionalLearningOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AdditionalLearningOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["l1_regularization_weight"] = _cntk_py.AdditionalLearningOptions_l1_regularization_weight_set
    __swig_getmethods__["l1_regularization_weight"] = _cntk_py.AdditionalLearningOptions_l1_regularization_weight_get
    if _newclass:
        l1_regularization_weight = _swig_property(_cntk_py.AdditionalLearningOptions_l1_regularization_weight_get, _cntk_py.AdditionalLearningOptions_l1_regularization_weight_set)
    __swig_setmethods__["l2_regularization_weight"] = _cntk_py.AdditionalLearningOptions_l2_regularization_weight_set
    __swig_getmethods__["l2_regularization_weight"] = _cntk_py.AdditionalLearningOptions_l2_regularization_weight_get
    if _newclass:
        l2_regularization_weight = _swig_property(_cntk_py.AdditionalLearningOptions_l2_regularization_weight_get, _cntk_py.AdditionalLearningOptions_l2_regularization_weight_set)
    __swig_setmethods__["gaussian_noise_injection_std_dev"] = _cntk_py.AdditionalLearningOptions_gaussian_noise_injection_std_dev_set
    __swig_getmethods__["gaussian_noise_injection_std_dev"] = _cntk_py.AdditionalLearningOptions_gaussian_noise_injection_std_dev_get
    if _newclass:
        gaussian_noise_injection_std_dev = _swig_property(_cntk_py.AdditionalLearningOptions_gaussian_noise_injection_std_dev_get, _cntk_py.AdditionalLearningOptions_gaussian_noise_injection_std_dev_set)
    __swig_setmethods__["gradient_clipping_threshold_per_sample"] = _cntk_py.AdditionalLearningOptions_gradient_clipping_threshold_per_sample_set
    __swig_getmethods__["gradient_clipping_threshold_per_sample"] = _cntk_py.AdditionalLearningOptions_gradient_clipping_threshold_per_sample_get
    if _newclass:
        gradient_clipping_threshold_per_sample = _swig_property(_cntk_py.AdditionalLearningOptions_gradient_clipping_threshold_per_sample_get, _cntk_py.AdditionalLearningOptions_gradient_clipping_threshold_per_sample_set)
    __swig_setmethods__["gradient_clipping_with_truncation"] = _cntk_py.AdditionalLearningOptions_gradient_clipping_with_truncation_set
    __swig_getmethods__["gradient_clipping_with_truncation"] = _cntk_py.AdditionalLearningOptions_gradient_clipping_with_truncation_get
    if _newclass:
        gradient_clipping_with_truncation = _swig_property(_cntk_py.AdditionalLearningOptions_gradient_clipping_with_truncation_get, _cntk_py.AdditionalLearningOptions_gradient_clipping_with_truncation_set)
    __swig_setmethods__["dict_options"] = _cntk_py.AdditionalLearningOptions_dict_options_set
    __swig_getmethods__["dict_options"] = _cntk_py.AdditionalLearningOptions_dict_options_get
    if _newclass:
        dict_options = _swig_property(_cntk_py.AdditionalLearningOptions_dict_options_get, _cntk_py.AdditionalLearningOptions_dict_options_set)

    def __init__(self):
        this = _cntk_py.new_AdditionalLearningOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_AdditionalLearningOptions
    __del__ = lambda self: None
AdditionalLearningOptions_swigregister = _cntk_py.AdditionalLearningOptions_swigregister
AdditionalLearningOptions_swigregister(AdditionalLearningOptions)


def default_unit_gain_value():
    return _cntk_py.default_unit_gain_value()
default_unit_gain_value = _cntk_py.default_unit_gain_value

def set_default_unit_gain_value(value):
    return _cntk_py.set_default_unit_gain_value(value)
set_default_unit_gain_value = _cntk_py.set_default_unit_gain_value

def default_use_mean_gradient_value():
    return _cntk_py.default_use_mean_gradient_value()
default_use_mean_gradient_value = _cntk_py.default_use_mean_gradient_value

def set_default_use_mean_gradient_value(value):
    return _cntk_py.set_default_use_mean_gradient_value(value)
set_default_use_mean_gradient_value = _cntk_py.set_default_use_mean_gradient_value
class Learner(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Learner, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Learner, name)
    __repr__ = _swig_repr

    def _update(self, gradientValues, trainingSampleCount, sweepEnd=False):
        return _cntk_py.Learner__update(self, gradientValues, trainingSampleCount, sweepEnd)

    def parameters(self):
        return _cntk_py.Learner_parameters(self)

    def create_checkpoint(self):
        return _cntk_py.Learner_create_checkpoint(self)

    def restore_from_checkpoint(self, arg0):
        return _cntk_py.Learner_restore_from_checkpoint(self, arg0)
    __swig_destroy__ = _cntk_py.delete_Learner
    __del__ = lambda self: None

    def current_version(self):
        return _cntk_py.Learner_current_version(self)

    def reset_learning_rate(self, learningRateSchedule):
        return _cntk_py.Learner_reset_learning_rate(self, learningRateSchedule)

    def reset_smoothed_gradients(self):
        return _cntk_py.Learner_reset_smoothed_gradients(self)

    def learning_rate(self):
        return _cntk_py.Learner_learning_rate(self)

    def total_number_of_samples_seen(self):
        return _cntk_py.Learner_total_number_of_samples_seen(self)

    def add_progress_writers(self, progressWriters):
        return _cntk_py.Learner_add_progress_writers(self, progressWriters)

    def _options(self, *args):
        return _cntk_py.Learner__options(self, *args)

    def is_compatible_mode(self):
        return _cntk_py.Learner_is_compatible_mode(self)

    def __init__(self, *args):
        if self.__class__ == Learner:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_Learner(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["minibatch_size"] = _cntk_py.Learner_minibatch_size_set
    __swig_getmethods__["minibatch_size"] = _cntk_py.Learner_minibatch_size_get
    if _newclass:
        minibatch_size = _swig_property(_cntk_py.Learner_minibatch_size_get, _cntk_py.Learner_minibatch_size_set)
    __swig_setmethods__["_learning_rate_schedule"] = _cntk_py.Learner__learning_rate_schedule_set
    __swig_getmethods__["_learning_rate_schedule"] = _cntk_py.Learner__learning_rate_schedule_get
    if _newclass:
        _learning_rate_schedule = _swig_property(_cntk_py.Learner__learning_rate_schedule_get, _cntk_py.Learner__learning_rate_schedule_set)
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_Learner(self)
        return weakref_proxy(self)
Learner_swigregister = _cntk_py.Learner_swigregister
Learner_swigregister(Learner)
Learner._MINIBATCH_SIZE = _cntk_py.cvar.Learner__MINIBATCH_SIZE
Learner.ignored_minibatch_size = _cntk_py.cvar.Learner_ignored_minibatch_size


def sgd_learner(*args):
    return _cntk_py.sgd_learner(*args)
sgd_learner = _cntk_py.sgd_learner

def momentum_sgd_learner(*args):
    return _cntk_py.momentum_sgd_learner(*args)
momentum_sgd_learner = _cntk_py.momentum_sgd_learner

def nesterov_learner(*args):
    return _cntk_py.nesterov_learner(*args)
nesterov_learner = _cntk_py.nesterov_learner

def fsada_grad_learner(*args):
    return _cntk_py.fsada_grad_learner(*args)
fsada_grad_learner = _cntk_py.fsada_grad_learner

def adam_learner(*args):
    return _cntk_py.adam_learner(*args)
adam_learner = _cntk_py.adam_learner

def ada_grad_learner(*args):
    return _cntk_py.ada_grad_learner(*args)
ada_grad_learner = _cntk_py.ada_grad_learner

def rmsprop_learner(*args):
    return _cntk_py.rmsprop_learner(*args)
rmsprop_learner = _cntk_py.rmsprop_learner

def ada_delta_learner(*args):
    return _cntk_py.ada_delta_learner(*args)
ada_delta_learner = _cntk_py.ada_delta_learner

def universal_learner(*args):
    return _cntk_py.universal_learner(*args)
universal_learner = _cntk_py.universal_learner
class DistributedLearner(Learner):
    __swig_setmethods__ = {}
    for _s in [Learner]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistributedLearner, name, value)
    __swig_getmethods__ = {}
    for _s in [Learner]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistributedLearner, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_communicator(self):
        return _cntk_py.DistributedLearner_get_communicator(self)

    def reset_learning_rate(self, learningRateSchedule):
        return _cntk_py.DistributedLearner_reset_learning_rate(self, learningRateSchedule)

    def learning_rate(self):
        return _cntk_py.DistributedLearner_learning_rate(self)

    def reset_smoothed_gradients(self):
        return _cntk_py.DistributedLearner_reset_smoothed_gradients(self)

    def parallelization_after(self):
        return _cntk_py.DistributedLearner_parallelization_after(self)

    def _update(self, *args):
        return _cntk_py.DistributedLearner__update(self, *args)

    def minibatch_size_scale_factor(self):
        return _cntk_py.DistributedLearner_minibatch_size_scale_factor(self)
    __swig_destroy__ = _cntk_py.delete_DistributedLearner
    __del__ = lambda self: None
DistributedLearner_swigregister = _cntk_py.DistributedLearner_swigregister
DistributedLearner_swigregister(DistributedLearner)


def create_data_parallel_distributed_learner(communicator, learner, distributeAfterSamples, useAsyncBufferedParameterUpdate=False):
    return _cntk_py.create_data_parallel_distributed_learner(communicator, learner, distributeAfterSamples, useAsyncBufferedParameterUpdate)
create_data_parallel_distributed_learner = _cntk_py.create_data_parallel_distributed_learner

def create_quantized_data_parallel_distributed_learner(communicator, learner, distributeAfterSamples, useAsyncBufferedParameterUpdate=False):
    return _cntk_py.create_quantized_data_parallel_distributed_learner(communicator, learner, distributeAfterSamples, useAsyncBufferedParameterUpdate)
create_quantized_data_parallel_distributed_learner = _cntk_py.create_quantized_data_parallel_distributed_learner

def create_block_momentum_distributed_learner(*args):
    return _cntk_py.create_block_momentum_distributed_learner(*args)
create_block_momentum_distributed_learner = _cntk_py.create_block_momentum_distributed_learner
class Evaluator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Evaluator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Evaluator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def test_minibatch_overload_for_minibatchdata(self, *args):
        return _cntk_py.Evaluator_test_minibatch_overload_for_minibatchdata(self, *args)

    def test_minibatch(self, *args):
        return _cntk_py.Evaluator_test_minibatch(self, *args)

    def evaluation_function(self):
        return _cntk_py.Evaluator_evaluation_function(self)

    def summarize_test_progress(self):
        return _cntk_py.Evaluator_summarize_test_progress(self)

    def progress_writers(self):
        return _cntk_py.Evaluator_progress_writers(self)
    __swig_destroy__ = _cntk_py.delete_Evaluator
    __del__ = lambda self: None
Evaluator_swigregister = _cntk_py.Evaluator_swigregister
Evaluator_swigregister(Evaluator)


def create_evaluator(*args):
    return _cntk_py.create_evaluator(*args)
create_evaluator = _cntk_py.create_evaluator
class Trainer(Evaluator):
    __swig_setmethods__ = {}
    for _s in [Evaluator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Trainer, name, value)
    __swig_getmethods__ = {}
    for _s in [Evaluator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Trainer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def train_minibatch_overload_for_minibatchdata(self, *args):
        return _cntk_py.Trainer_train_minibatch_overload_for_minibatchdata(self, *args)

    def train_minibatch(self, *args):
        return _cntk_py.Trainer_train_minibatch(self, *args)

    def save_checkpoint(self, *args):
        return _cntk_py.Trainer_save_checkpoint(self, *args)

    def restore_from_checkpoint(self, filePath):
        return _cntk_py.Trainer_restore_from_checkpoint(self, filePath)

    def model(self):
        return _cntk_py.Trainer_model(self)

    def loss_function(self):
        return _cntk_py.Trainer_loss_function(self)

    def previous_minibatch_loss_average(self):
        return _cntk_py.Trainer_previous_minibatch_loss_average(self)

    def previous_minibatch_evaluation_average(self):
        return _cntk_py.Trainer_previous_minibatch_evaluation_average(self)

    def previous_minibatch_sample_count(self):
        return _cntk_py.Trainer_previous_minibatch_sample_count(self)

    def parameter_learners(self):
        return _cntk_py.Trainer_parameter_learners(self)

    def total_number_of_samples_seen(self):
        return _cntk_py.Trainer_total_number_of_samples_seen(self)

    def summarize_training_progress(self):
        return _cntk_py.Trainer_summarize_training_progress(self)
    __swig_destroy__ = _cntk_py.delete_Trainer
    __del__ = lambda self: None
Trainer_swigregister = _cntk_py.Trainer_swigregister
Trainer_swigregister(Trainer)


def create_trainer(*args):
    return _cntk_py.create_trainer(*args)
create_trainer = _cntk_py.create_trainer
class MinibatchData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinibatchData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinibatchData, name)

    def __init__(self, *args):
        this = _cntk_py.new_MinibatchData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def as_string(self):
        return _cntk_py.MinibatchData_as_string(self)
    __swig_setmethods__["data"] = _cntk_py.MinibatchData_data_set
    __swig_getmethods__["data"] = _cntk_py.MinibatchData_data_get
    if _newclass:
        data = _swig_property(_cntk_py.MinibatchData_data_get, _cntk_py.MinibatchData_data_set)
    __swig_setmethods__["number_of_sequences"] = _cntk_py.MinibatchData_number_of_sequences_set
    __swig_getmethods__["number_of_sequences"] = _cntk_py.MinibatchData_number_of_sequences_get
    if _newclass:
        number_of_sequences = _swig_property(_cntk_py.MinibatchData_number_of_sequences_get, _cntk_py.MinibatchData_number_of_sequences_set)
    __swig_setmethods__["number_of_samples"] = _cntk_py.MinibatchData_number_of_samples_set
    __swig_getmethods__["number_of_samples"] = _cntk_py.MinibatchData_number_of_samples_get
    if _newclass:
        number_of_samples = _swig_property(_cntk_py.MinibatchData_number_of_samples_get, _cntk_py.MinibatchData_number_of_samples_set)
    __swig_setmethods__["sweep_end"] = _cntk_py.MinibatchData_sweep_end_set
    __swig_getmethods__["sweep_end"] = _cntk_py.MinibatchData_sweep_end_get
    if _newclass:
        sweep_end = _swig_property(_cntk_py.MinibatchData_sweep_end_get, _cntk_py.MinibatchData_sweep_end_set)

    def __str__(self):
        return _cntk_py.MinibatchData___str__(self)

    def __repr__(self):
        return _cntk_py.MinibatchData___repr__(self)
    __swig_destroy__ = _cntk_py.delete_MinibatchData
    __del__ = lambda self: None
MinibatchData_swigregister = _cntk_py.MinibatchData_swigregister
MinibatchData_swigregister(MinibatchData)

class MinibatchSource(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinibatchSource, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinibatchSource, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def stream_infos(self):
        return _cntk_py.MinibatchSource_stream_infos(self)
    __swig_destroy__ = _cntk_py.delete_MinibatchSource
    __del__ = lambda self: None

    def get_checkpoint_state(self):
        return _cntk_py.MinibatchSource_get_checkpoint_state(self)

    def restore_from_checkpoint(self, arg2):
        return _cntk_py.MinibatchSource_restore_from_checkpoint(self, arg2)

    def is_infinite(self):
        return _cntk_py.MinibatchSource_is_infinite(self)

    def stream_info(self, *args):
        return _cntk_py.MinibatchSource_stream_info(self, *args)

    def get_next_minibatch(self, *args):
        return _cntk_py.MinibatchSource_get_next_minibatch(self, *args)
MinibatchSource_swigregister = _cntk_py.MinibatchSource_swigregister
MinibatchSource_swigregister(MinibatchSource)
MinibatchSource.infinitely_repeat = _cntk_py.cvar.MinibatchSource_infinitely_repeat
MinibatchSource.full_data_sweep = _cntk_py.cvar.MinibatchSource_full_data_sweep
MinibatchSource.default_randomization_window_in_chunks = _cntk_py.cvar.MinibatchSource_default_randomization_window_in_chunks

class MinibatchSourceConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinibatchSourceConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinibatchSourceConfig, name)
    __repr__ = _swig_repr

    def __init__(self, deserializers, randomize=True):
        this = _cntk_py.new_MinibatchSourceConfig(deserializers, randomize)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["max_samples"] = _cntk_py.MinibatchSourceConfig_max_samples_set
    __swig_getmethods__["max_samples"] = _cntk_py.MinibatchSourceConfig_max_samples_get
    if _newclass:
        max_samples = _swig_property(_cntk_py.MinibatchSourceConfig_max_samples_get, _cntk_py.MinibatchSourceConfig_max_samples_set)
    __swig_setmethods__["max_sweeps"] = _cntk_py.MinibatchSourceConfig_max_sweeps_set
    __swig_getmethods__["max_sweeps"] = _cntk_py.MinibatchSourceConfig_max_sweeps_get
    if _newclass:
        max_sweeps = _swig_property(_cntk_py.MinibatchSourceConfig_max_sweeps_get, _cntk_py.MinibatchSourceConfig_max_sweeps_set)
    __swig_setmethods__["randomization_window_in_chunks"] = _cntk_py.MinibatchSourceConfig_randomization_window_in_chunks_set
    __swig_getmethods__["randomization_window_in_chunks"] = _cntk_py.MinibatchSourceConfig_randomization_window_in_chunks_get
    if _newclass:
        randomization_window_in_chunks = _swig_property(_cntk_py.MinibatchSourceConfig_randomization_window_in_chunks_get, _cntk_py.MinibatchSourceConfig_randomization_window_in_chunks_set)
    __swig_setmethods__["randomization_window_in_samples"] = _cntk_py.MinibatchSourceConfig_randomization_window_in_samples_set
    __swig_getmethods__["randomization_window_in_samples"] = _cntk_py.MinibatchSourceConfig_randomization_window_in_samples_get
    if _newclass:
        randomization_window_in_samples = _swig_property(_cntk_py.MinibatchSourceConfig_randomization_window_in_samples_get, _cntk_py.MinibatchSourceConfig_randomization_window_in_samples_set)
    __swig_setmethods__["randomization_seed"] = _cntk_py.MinibatchSourceConfig_randomization_seed_set
    __swig_getmethods__["randomization_seed"] = _cntk_py.MinibatchSourceConfig_randomization_seed_get
    if _newclass:
        randomization_seed = _swig_property(_cntk_py.MinibatchSourceConfig_randomization_seed_get, _cntk_py.MinibatchSourceConfig_randomization_seed_set)
    __swig_setmethods__["trace_level"] = _cntk_py.MinibatchSourceConfig_trace_level_set
    __swig_getmethods__["trace_level"] = _cntk_py.MinibatchSourceConfig_trace_level_get
    if _newclass:
        trace_level = _swig_property(_cntk_py.MinibatchSourceConfig_trace_level_get, _cntk_py.MinibatchSourceConfig_trace_level_set)
    __swig_setmethods__["truncation_length"] = _cntk_py.MinibatchSourceConfig_truncation_length_set
    __swig_getmethods__["truncation_length"] = _cntk_py.MinibatchSourceConfig_truncation_length_get
    if _newclass:
        truncation_length = _swig_property(_cntk_py.MinibatchSourceConfig_truncation_length_get, _cntk_py.MinibatchSourceConfig_truncation_length_set)
    __swig_setmethods__["is_frame_mode_enabled"] = _cntk_py.MinibatchSourceConfig_is_frame_mode_enabled_set
    __swig_getmethods__["is_frame_mode_enabled"] = _cntk_py.MinibatchSourceConfig_is_frame_mode_enabled_get
    if _newclass:
        is_frame_mode_enabled = _swig_property(_cntk_py.MinibatchSourceConfig_is_frame_mode_enabled_get, _cntk_py.MinibatchSourceConfig_is_frame_mode_enabled_set)
    __swig_getmethods__["is_multithreaded"] = _cntk_py.MinibatchSourceConfig_is_multithreaded_get
    if _newclass:
        is_multithreaded = _swig_property(_cntk_py.MinibatchSourceConfig_is_multithreaded_get)
    __swig_setmethods__["deserializers"] = _cntk_py.MinibatchSourceConfig_deserializers_set
    __swig_getmethods__["deserializers"] = _cntk_py.MinibatchSourceConfig_deserializers_get
    if _newclass:
        deserializers = _swig_property(_cntk_py.MinibatchSourceConfig_deserializers_get, _cntk_py.MinibatchSourceConfig_deserializers_set)
    __swig_destroy__ = _cntk_py.delete_MinibatchSourceConfig
    __del__ = lambda self: None
MinibatchSourceConfig_swigregister = _cntk_py.MinibatchSourceConfig_swigregister
MinibatchSourceConfig_swigregister(MinibatchSourceConfig)


def create_composite_minibatch_source(configuration):
    return _cntk_py.create_composite_minibatch_source(configuration)
create_composite_minibatch_source = _cntk_py.create_composite_minibatch_source
class StreamConfiguration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamConfiguration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamConfiguration, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_StreamConfiguration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["m_stream_name"] = _cntk_py.StreamConfiguration_m_stream_name_set
    __swig_getmethods__["m_stream_name"] = _cntk_py.StreamConfiguration_m_stream_name_get
    if _newclass:
        m_stream_name = _swig_property(_cntk_py.StreamConfiguration_m_stream_name_get, _cntk_py.StreamConfiguration_m_stream_name_set)
    __swig_setmethods__["m_dim"] = _cntk_py.StreamConfiguration_m_dim_set
    __swig_getmethods__["m_dim"] = _cntk_py.StreamConfiguration_m_dim_get
    if _newclass:
        m_dim = _swig_property(_cntk_py.StreamConfiguration_m_dim_get, _cntk_py.StreamConfiguration_m_dim_set)
    __swig_setmethods__["m_is_sparse"] = _cntk_py.StreamConfiguration_m_is_sparse_set
    __swig_getmethods__["m_is_sparse"] = _cntk_py.StreamConfiguration_m_is_sparse_get
    if _newclass:
        m_is_sparse = _swig_property(_cntk_py.StreamConfiguration_m_is_sparse_get, _cntk_py.StreamConfiguration_m_is_sparse_set)
    __swig_setmethods__["m_stream_alias"] = _cntk_py.StreamConfiguration_m_stream_alias_set
    __swig_getmethods__["m_stream_alias"] = _cntk_py.StreamConfiguration_m_stream_alias_get
    if _newclass:
        m_stream_alias = _swig_property(_cntk_py.StreamConfiguration_m_stream_alias_get, _cntk_py.StreamConfiguration_m_stream_alias_set)
    __swig_setmethods__["m_defines_mb_size"] = _cntk_py.StreamConfiguration_m_defines_mb_size_set
    __swig_getmethods__["m_defines_mb_size"] = _cntk_py.StreamConfiguration_m_defines_mb_size_get
    if _newclass:
        m_defines_mb_size = _swig_property(_cntk_py.StreamConfiguration_m_defines_mb_size_get, _cntk_py.StreamConfiguration_m_defines_mb_size_set)
    __swig_destroy__ = _cntk_py.delete_StreamConfiguration
    __del__ = lambda self: None
StreamConfiguration_swigregister = _cntk_py.StreamConfiguration_swigregister
StreamConfiguration_swigregister(StreamConfiguration)

class HTKFeatureConfiguration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTKFeatureConfiguration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTKFeatureConfiguration, name)
    __repr__ = _swig_repr

    def __init__(self, streamName, scp, dim, left, right, broadcast, definesMbSize=False):
        this = _cntk_py.new_HTKFeatureConfiguration(streamName, scp, dim, left, right, broadcast, definesMbSize)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["m_stream_name"] = _cntk_py.HTKFeatureConfiguration_m_stream_name_set
    __swig_getmethods__["m_stream_name"] = _cntk_py.HTKFeatureConfiguration_m_stream_name_get
    if _newclass:
        m_stream_name = _swig_property(_cntk_py.HTKFeatureConfiguration_m_stream_name_get, _cntk_py.HTKFeatureConfiguration_m_stream_name_set)
    __swig_setmethods__["m_scp"] = _cntk_py.HTKFeatureConfiguration_m_scp_set
    __swig_getmethods__["m_scp"] = _cntk_py.HTKFeatureConfiguration_m_scp_get
    if _newclass:
        m_scp = _swig_property(_cntk_py.HTKFeatureConfiguration_m_scp_get, _cntk_py.HTKFeatureConfiguration_m_scp_set)
    __swig_setmethods__["m_dim"] = _cntk_py.HTKFeatureConfiguration_m_dim_set
    __swig_getmethods__["m_dim"] = _cntk_py.HTKFeatureConfiguration_m_dim_get
    if _newclass:
        m_dim = _swig_property(_cntk_py.HTKFeatureConfiguration_m_dim_get, _cntk_py.HTKFeatureConfiguration_m_dim_set)
    __swig_setmethods__["m_left"] = _cntk_py.HTKFeatureConfiguration_m_left_set
    __swig_getmethods__["m_left"] = _cntk_py.HTKFeatureConfiguration_m_left_get
    if _newclass:
        m_left = _swig_property(_cntk_py.HTKFeatureConfiguration_m_left_get, _cntk_py.HTKFeatureConfiguration_m_left_set)
    __swig_setmethods__["m_right"] = _cntk_py.HTKFeatureConfiguration_m_right_set
    __swig_getmethods__["m_right"] = _cntk_py.HTKFeatureConfiguration_m_right_get
    if _newclass:
        m_right = _swig_property(_cntk_py.HTKFeatureConfiguration_m_right_get, _cntk_py.HTKFeatureConfiguration_m_right_set)
    __swig_setmethods__["m_broadcast"] = _cntk_py.HTKFeatureConfiguration_m_broadcast_set
    __swig_getmethods__["m_broadcast"] = _cntk_py.HTKFeatureConfiguration_m_broadcast_get
    if _newclass:
        m_broadcast = _swig_property(_cntk_py.HTKFeatureConfiguration_m_broadcast_get, _cntk_py.HTKFeatureConfiguration_m_broadcast_set)
    __swig_setmethods__["m_defines_mb_size"] = _cntk_py.HTKFeatureConfiguration_m_defines_mb_size_set
    __swig_getmethods__["m_defines_mb_size"] = _cntk_py.HTKFeatureConfiguration_m_defines_mb_size_get
    if _newclass:
        m_defines_mb_size = _swig_property(_cntk_py.HTKFeatureConfiguration_m_defines_mb_size_get, _cntk_py.HTKFeatureConfiguration_m_defines_mb_size_set)
    __swig_destroy__ = _cntk_py.delete_HTKFeatureConfiguration
    __del__ = lambda self: None
HTKFeatureConfiguration_swigregister = _cntk_py.HTKFeatureConfiguration_swigregister
HTKFeatureConfiguration_swigregister(HTKFeatureConfiguration)


def reader_crop(*args):
    return _cntk_py.reader_crop(*args)
reader_crop = _cntk_py.reader_crop

def reader_scale(*args):
    return _cntk_py.reader_scale(*args)
reader_scale = _cntk_py.reader_scale

def reader_mean(meanFile):
    return _cntk_py.reader_mean(meanFile)
reader_mean = _cntk_py.reader_mean

def reader_color(brightnessRadius=0.0, contrastRadius=0.0, saturationRadius=0.0):
    return _cntk_py.reader_color(brightnessRadius, contrastRadius, saturationRadius)
reader_color = _cntk_py.reader_color

def image_deserializer(*args):
    return _cntk_py.image_deserializer(*args)
image_deserializer = _cntk_py.image_deserializer

def base64_image_deserializer(*args):
    return _cntk_py.base64_image_deserializer(*args)
base64_image_deserializer = _cntk_py.base64_image_deserializer

def ctf_deserializer(fileName, streams):
    return _cntk_py.ctf_deserializer(fileName, streams)
ctf_deserializer = _cntk_py.ctf_deserializer

def cbf_deserializer(*args):
    return _cntk_py.cbf_deserializer(*args)
cbf_deserializer = _cntk_py.cbf_deserializer

def htk_feature_deserializer(streams):
    return _cntk_py.htk_feature_deserializer(streams)
htk_feature_deserializer = _cntk_py.htk_feature_deserializer

def htk_mlf_deserializer(streamName, labelMappingFile, dimension, mlfFiles, phoneBoundaries=False):
    return _cntk_py.htk_mlf_deserializer(streamName, labelMappingFile, dimension, mlfFiles, phoneBoundaries)
htk_mlf_deserializer = _cntk_py.htk_mlf_deserializer

def text_format_minibatch_source(*args):
    return _cntk_py.text_format_minibatch_source(*args)
text_format_minibatch_source = _cntk_py.text_format_minibatch_source

def compute_input_per_dim_means_and_inv_std_devs(*args):
    return _cntk_py.compute_input_per_dim_means_and_inv_std_devs(*args)
compute_input_per_dim_means_and_inv_std_devs = _cntk_py.compute_input_per_dim_means_and_inv_std_devs

def set_max_num_cputhreads(numCPUThreads):
    return _cntk_py.set_max_num_cputhreads(numCPUThreads)
set_max_num_cputhreads = _cntk_py.set_max_num_cputhreads

def get_max_num_cputhreads():
    return _cntk_py.get_max_num_cputhreads()
get_max_num_cputhreads = _cntk_py.get_max_num_cputhreads
class DistributedWorkerDescriptor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistributedWorkerDescriptor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DistributedWorkerDescriptor, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_global_rank"] = _cntk_py.DistributedWorkerDescriptor_m_global_rank_set
    __swig_getmethods__["m_global_rank"] = _cntk_py.DistributedWorkerDescriptor_m_global_rank_get
    if _newclass:
        m_global_rank = _swig_property(_cntk_py.DistributedWorkerDescriptor_m_global_rank_get, _cntk_py.DistributedWorkerDescriptor_m_global_rank_set)
    __swig_setmethods__["m_host_id"] = _cntk_py.DistributedWorkerDescriptor_m_host_id_set
    __swig_getmethods__["m_host_id"] = _cntk_py.DistributedWorkerDescriptor_m_host_id_get
    if _newclass:
        m_host_id = _swig_property(_cntk_py.DistributedWorkerDescriptor_m_host_id_get, _cntk_py.DistributedWorkerDescriptor_m_host_id_set)

    def is_main(self):
        return _cntk_py.DistributedWorkerDescriptor_is_main(self)

    def __init__(self):
        this = _cntk_py.new_DistributedWorkerDescriptor()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_DistributedWorkerDescriptor
    __del__ = lambda self: None
DistributedWorkerDescriptor_swigregister = _cntk_py.DistributedWorkerDescriptor_swigregister
DistributedWorkerDescriptor_swigregister(DistributedWorkerDescriptor)


def __eq__(*args):
    return _cntk_py.__eq__(*args)
__eq__ = _cntk_py.__eq__
class DistributedCommunicator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistributedCommunicator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DistributedCommunicator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def workers(self):
        return _cntk_py.DistributedCommunicator_workers(self)

    def current_worker(self):
        return _cntk_py.DistributedCommunicator_current_worker(self)

    def sub_group(self, subGroupWorkers):
        return _cntk_py.DistributedCommunicator_sub_group(self, subGroupWorkers)

    def concatenate(self, *args):
        return _cntk_py.DistributedCommunicator_concatenate(self, *args)

    def gather(self, input, output, sendToWorkers):
        return _cntk_py.DistributedCommunicator_gather(self, input, output, sendToWorkers)

    def aggregate_in_place(self, values, sendToWorkers):
        return _cntk_py.DistributedCommunicator_aggregate_in_place(self, values, sendToWorkers)

    def all_reduce_sparse_block_column(self, arg2):
        return _cntk_py.DistributedCommunicator_all_reduce_sparse_block_column(self, arg2)

    def aggregate(self, values, outputValues, sendToWorkers):
        return _cntk_py.DistributedCommunicator_aggregate(self, values, outputValues, sendToWorkers)
    __swig_destroy__ = _cntk_py.delete_DistributedCommunicator
    __del__ = lambda self: None
    if _newclass:
        finalize = staticmethod(_cntk_py.DistributedCommunicator_finalize)
    else:
        finalize = _cntk_py.DistributedCommunicator_finalize

    def barrier(self):
        return _cntk_py.DistributedCommunicator_barrier(self)
DistributedCommunicator_swigregister = _cntk_py.DistributedCommunicator_swigregister
DistributedCommunicator_swigregister(DistributedCommunicator)

def DistributedCommunicator_finalize():
    return _cntk_py.DistributedCommunicator_finalize()
DistributedCommunicator_finalize = _cntk_py.DistributedCommunicator_finalize

class QuantizedDistributedCommunicator(DistributedCommunicator):
    __swig_setmethods__ = {}
    for _s in [DistributedCommunicator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, QuantizedDistributedCommunicator, name, value)
    __swig_getmethods__ = {}
    for _s in [DistributedCommunicator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, QuantizedDistributedCommunicator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def quantized_aggregate(self, inValues, valueQuantizationResidues, stripeQuantizationResidues, aggregatedOutputs, newQuantizationResidues, newStripeQuantizationResidues, sendToWorkers):
        return _cntk_py.QuantizedDistributedCommunicator_quantized_aggregate(self, inValues, valueQuantizationResidues, stripeQuantizationResidues, aggregatedOutputs, newQuantizationResidues, newStripeQuantizationResidues, sendToWorkers)

    def quantized_aggregate_in_place(self, inValues, valueQuantizationResidues, stripeQuantizationResidues, sendToWorkers):
        return _cntk_py.QuantizedDistributedCommunicator_quantized_aggregate_in_place(self, inValues, valueQuantizationResidues, stripeQuantizationResidues, sendToWorkers)
    __swig_destroy__ = _cntk_py.delete_QuantizedDistributedCommunicator
    __del__ = lambda self: None
QuantizedDistributedCommunicator_swigregister = _cntk_py.QuantizedDistributedCommunicator_swigregister
QuantizedDistributedCommunicator_swigregister(QuantizedDistributedCommunicator)


def mpicommunicator(*args):
    return _cntk_py.mpicommunicator(*args)
mpicommunicator = _cntk_py.mpicommunicator

def quantized_mpicommunicator(zeroThresholdFor1Bit, useQuantizationForSelfStripe, numQuantizationBits):
    return _cntk_py.quantized_mpicommunicator(zeroThresholdFor1Bit, useQuantizationForSelfStripe, numQuantizationBits)
quantized_mpicommunicator = _cntk_py.quantized_mpicommunicator
class CrossValidationConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CrossValidationConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CrossValidationConfig, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_CrossValidationConfig(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_CrossValidationConfig
    __del__ = lambda self: None
CrossValidationConfig_swigregister = _cntk_py.CrossValidationConfig_swigregister
CrossValidationConfig_swigregister(CrossValidationConfig)

class CheckpointConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CheckpointConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CheckpointConfig, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_CheckpointConfig(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_CheckpointConfig
    __del__ = lambda self: None
CheckpointConfig_swigregister = _cntk_py.CheckpointConfig_swigregister
CheckpointConfig_swigregister(CheckpointConfig)

class TestConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TestConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TestConfig, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_TestConfig(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_TestConfig
    __del__ = lambda self: None
TestConfig_swigregister = _cntk_py.TestConfig_swigregister
TestConfig_swigregister(TestConfig)

class TrainingSession(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrainingSession, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TrainingSession, name)
    __repr__ = _swig_repr

    def __init__(self, trainer, trainingSource, minibatchSizeSchedule, inputVarToStream, maxNumTrainingSamples, progressFrequency, checkpointing, crossValidation, test):
        if self.__class__ == TrainingSession:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_TrainingSession(_self, trainer, trainingSource, minibatchSizeSchedule, inputVarToStream, maxNumTrainingSamples, progressFrequency, checkpointing, crossValidation, test)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def train(self, computeDevice):
        return _cntk_py.TrainingSession_train(self, computeDevice)

    def restore_from_checkpoint(self, checkpointFileName):
        return _cntk_py.TrainingSession_restore_from_checkpoint(self, checkpointFileName)
    __swig_destroy__ = _cntk_py.delete_TrainingSession
    __del__ = lambda self: None

    def get_minibatch_size(self):
        return _cntk_py.TrainingSession_get_minibatch_size(self)

    def on_minibatch_start(self):
        return _cntk_py.TrainingSession_on_minibatch_start(self)

    def on_minibatch_end(self):
        return _cntk_py.TrainingSession_on_minibatch_end(self)

    def on_checkpoint_start(self, arg2):
        return _cntk_py.TrainingSession_on_checkpoint_start(self, arg2)

    def on_checkpoint_end(self, arg0):
        return _cntk_py.TrainingSession_on_checkpoint_end(self, arg0)

    def on_cross_validation_start(self, arg0):
        return _cntk_py.TrainingSession_on_cross_validation_start(self, arg0)

    def on_cross_validation_end(self, arg0, arg1, arg2, arg3):
        return _cntk_py.TrainingSession_on_cross_validation_end(self, arg0, arg1, arg2, arg3)
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_TrainingSession(self)
        return weakref_proxy(self)
TrainingSession_swigregister = _cntk_py.TrainingSession_swigregister
TrainingSession_swigregister(TrainingSession)

class ProgressWriter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProgressWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ProgressWriter, name)
    __repr__ = _swig_repr

    def __init__(self, trainingUpdateWriteFrequency, trainingFirstUpdatesToWrite, testUpdateWriteFrequency, testFirstUpdatesToWrite, distributedSyncUpdateWriteFrequency, distributedSyncFirstUpdatesToWrite):
        if self.__class__ == ProgressWriter:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_ProgressWriter(_self, trainingUpdateWriteFrequency, trainingFirstUpdatesToWrite, testUpdateWriteFrequency, testFirstUpdatesToWrite, distributedSyncUpdateWriteFrequency, distributedSyncFirstUpdatesToWrite)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_ProgressWriter
    __del__ = lambda self: None

    def on_write_training_update(self, arg0, arg1, arg2, arg3):
        return _cntk_py.ProgressWriter_on_write_training_update(self, arg0, arg1, arg2, arg3)

    def on_write_test_update(self, arg0, arg1, arg2):
        return _cntk_py.ProgressWriter_on_write_test_update(self, arg0, arg1, arg2)

    def on_write_distributed_sync_update(self, arg0, arg1, arg2):
        return _cntk_py.ProgressWriter_on_write_distributed_sync_update(self, arg0, arg1, arg2)

    def on_training_update_end(self):
        return _cntk_py.ProgressWriter_on_training_update_end(self)

    def on_write_training_summary(self, arg0, arg1, arg2, arg3, arg4, arg5):
        return _cntk_py.ProgressWriter_on_write_training_summary(self, arg0, arg1, arg2, arg3, arg4, arg5)

    def on_write_test_summary(self, arg0, arg1, arg2, arg3, arg4):
        return _cntk_py.ProgressWriter_on_write_test_summary(self, arg0, arg1, arg2, arg3, arg4)

    def write(self, arg0, arg1):
        return _cntk_py.ProgressWriter_write(self, arg0, arg1)

    def total_training_updates(self):
        return _cntk_py.ProgressWriter_total_training_updates(self)

    def total_test_updates(self):
        return _cntk_py.ProgressWriter_total_test_updates(self)
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_ProgressWriter(self)
        return weakref_proxy(self)
ProgressWriter_swigregister = _cntk_py.ProgressWriter_swigregister
ProgressWriter_swigregister(ProgressWriter)


def create_training_session(*args):
    return _cntk_py.create_training_session(*args)
create_training_session = _cntk_py.create_training_session

def crop(*args):
    return _cntk_py.crop(*args)
crop = _cntk_py.crop
class GilStateGuard(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GilStateGuard, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GilStateGuard, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _cntk_py.new_GilStateGuard()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_GilStateGuard
    __del__ = lambda self: None
GilStateGuard_swigregister = _cntk_py.GilStateGuard_swigregister
GilStateGuard_swigregister(GilStateGuard)


def make_shared(object):
    return _cntk_py.make_shared(object)
make_shared = _cntk_py.make_shared
class DenseDataFromPy(DenseSequenceData):
    __swig_setmethods__ = {}
    for _s in [DenseSequenceData]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DenseDataFromPy, name, value)
    __swig_getmethods__ = {}
    for _s in [DenseSequenceData]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DenseDataFromPy, name)
    __repr__ = _swig_repr

    def __init__(self, ptr, numberOfSamples, object):
        this = _cntk_py.new_DenseDataFromPy(ptr, numberOfSamples, object)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_data_buffer(self):
        return _cntk_py.DenseDataFromPy_get_data_buffer(self)

    def get_sample_shape(self):
        return _cntk_py.DenseDataFromPy_get_sample_shape(self)
    __swig_destroy__ = _cntk_py.delete_DenseDataFromPy
    __del__ = lambda self: None
DenseDataFromPy_swigregister = _cntk_py.DenseDataFromPy_swigregister
DenseDataFromPy_swigregister(DenseDataFromPy)

class SparseDataFromPy(SparseSequenceData):
    __swig_setmethods__ = {}
    for _s in [SparseSequenceData]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparseDataFromPy, name, value)
    __swig_getmethods__ = {}
    for _s in [SparseSequenceData]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SparseDataFromPy, name)
    __repr__ = _swig_repr

    def __init__(self, data, indices, nonZeroCount, numberOfSamples, object):
        this = _cntk_py.new_SparseDataFromPy(data, indices, nonZeroCount, numberOfSamples, object)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_data_buffer(self):
        return _cntk_py.SparseDataFromPy_get_data_buffer(self)

    def get_sample_shape(self):
        return _cntk_py.SparseDataFromPy_get_sample_shape(self)
    __swig_destroy__ = _cntk_py.delete_SparseDataFromPy
    __del__ = lambda self: None
SparseDataFromPy_swigregister = _cntk_py.SparseDataFromPy_swigregister
SparseDataFromPy_swigregister(SparseDataFromPy)

class SwigChunk(Chunk):
    __swig_setmethods__ = {}
    for _s in [Chunk]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigChunk, name, value)
    __swig_getmethods__ = {}
    for _s in [Chunk]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SwigChunk, name)
    __repr__ = _swig_repr

    def __init__(self, chunkId, streamInfos, chunk):
        if self.__class__ == SwigChunk:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_SwigChunk(_self, chunkId, streamInfos, chunk)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_first_dimension(self, o):
        return _cntk_py.SwigChunk_get_first_dimension(self, o)

    def fill_chunk_data(self, streamIndex, o, dataSize):
        return _cntk_py.SwigChunk_fill_chunk_data(self, streamIndex, o, dataSize)

    def fill_data_with_dense_samples(self, streamIndex, o, dataSize):
        return _cntk_py.SwigChunk_fill_data_with_dense_samples(self, streamIndex, o, dataSize)

    def fill_data_with_sparse_samples(self, streamIndex, o, dataSize):
        return _cntk_py.SwigChunk_fill_data_with_sparse_samples(self, streamIndex, o, dataSize)

    def fill_data_with_sequences(self, streamIndex, o, dataSize):
        return _cntk_py.SwigChunk_fill_data_with_sequences(self, streamIndex, o, dataSize)

    def sequence_infos(self, descriptions):
        return _cntk_py.SwigChunk_sequence_infos(self, descriptions)

    def get_sequence(self, sequenceIndex, result):
        return _cntk_py.SwigChunk_get_sequence(self, sequenceIndex, result)

    def get_property(self, object, propertyName):
        return _cntk_py.SwigChunk_get_property(self, object, propertyName)
    __swig_destroy__ = _cntk_py.delete_SwigChunk
    __del__ = lambda self: None
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_SwigChunk(self)
        return weakref_proxy(self)
SwigChunk_swigregister = _cntk_py.SwigChunk_swigregister
SwigChunk_swigregister(SwigChunk)

class SwigDataDeserializer(DataDeserializer):
    __swig_setmethods__ = {}
    for _s in [DataDeserializer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigDataDeserializer, name, value)
    __swig_getmethods__ = {}
    for _s in [DataDeserializer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SwigDataDeserializer, name)
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == SwigDataDeserializer:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_SwigDataDeserializer(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def _stream_infos(self, arg0):
        return _cntk_py.SwigDataDeserializer__stream_infos(self, arg0)

    def _chunk_infos(self, arg0):
        return _cntk_py.SwigDataDeserializer__chunk_infos(self, arg0)

    def _get_chunk(self, chunkId):
        return _cntk_py.SwigDataDeserializer__get_chunk(self, chunkId)

    def stream_infos(self):
        return _cntk_py.SwigDataDeserializer_stream_infos(self)

    def chunk_infos(self):
        return _cntk_py.SwigDataDeserializer_chunk_infos(self)

    def get_chunk(self, chunkId):
        return _cntk_py.SwigDataDeserializer_get_chunk(self, chunkId)

    def get_sequence_info(self, primary, description):
        return _cntk_py.SwigDataDeserializer_get_sequence_info(self, primary, description)

    def sequence_infos_for_chunk(self, chunkId, descriptions):
        return _cntk_py.SwigDataDeserializer_sequence_infos_for_chunk(self, chunkId, descriptions)
    __swig_destroy__ = _cntk_py.delete_SwigDataDeserializer
    __del__ = lambda self: None
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_SwigDataDeserializer(self)
        return weakref_proxy(self)
SwigDataDeserializer_swigregister = _cntk_py.SwigDataDeserializer_swigregister
SwigDataDeserializer_swigregister(SwigDataDeserializer)


def trainer_impl(*args):
    return _cntk_py.trainer_impl(*args)
trainer_impl = _cntk_py.trainer_impl

def worker_global_rank():
    return _cntk_py.worker_global_rank()
worker_global_rank = _cntk_py.worker_global_rank

def number_of_workers():
    return _cntk_py.number_of_workers()
number_of_workers = _cntk_py.number_of_workers
class SwigMinibatchSource(MinibatchSource):
    __swig_setmethods__ = {}
    for _s in [MinibatchSource]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigMinibatchSource, name, value)
    __swig_getmethods__ = {}
    for _s in [MinibatchSource]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SwigMinibatchSource, name)
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == SwigMinibatchSource:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_SwigMinibatchSource(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def _stream_infos(self, streamInfos):
        return _cntk_py.SwigMinibatchSource__stream_infos(self, streamInfos)

    def _next_minibatch(self, *args):
        return _cntk_py.SwigMinibatchSource__next_minibatch(self, *args)

    def _get_checkpoint_state(self):
        return _cntk_py.SwigMinibatchSource__get_checkpoint_state(self)
    __swig_destroy__ = _cntk_py.delete_SwigMinibatchSource
    __del__ = lambda self: None
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_SwigMinibatchSource(self)
        return weakref_proxy(self)
SwigMinibatchSource_swigregister = _cntk_py.SwigMinibatchSource_swigregister
SwigMinibatchSource_swigregister(SwigMinibatchSource)

class DeserializerFactory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeserializerFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DeserializerFactory, name)
    __repr__ = _swig_repr

    def __call__(self, arg0):
        return _cntk_py.DeserializerFactory___call__(self, arg0)
    __swig_destroy__ = _cntk_py.delete_DeserializerFactory
    __del__ = lambda self: None

    def __init__(self):
        if self.__class__ == DeserializerFactory:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_DeserializerFactory(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_DeserializerFactory(self)
        return weakref_proxy(self)
DeserializerFactory_swigregister = _cntk_py.DeserializerFactory_swigregister
DeserializerFactory_swigregister(DeserializerFactory)


def _register_deserializer_factory(factoryImpl):
    return _cntk_py._register_deserializer_factory(factoryImpl)
_register_deserializer_factory = _cntk_py._register_deserializer_factory

def create_deserializer(deserializer, id):
    return _cntk_py.create_deserializer(deserializer, id)
create_deserializer = _cntk_py.create_deserializer
class minibatch_size_schedule(IDictionarySerializable):
    __swig_setmethods__ = {}
    for _s in [IDictionarySerializable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, minibatch_size_schedule, name, value)
    __swig_getmethods__ = {}
    for _s in [IDictionarySerializable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, minibatch_size_schedule, name)
    __repr__ = _swig_repr
    full_data_sweep = _cntk_py.minibatch_size_schedule_full_data_sweep
    ignored_minibatch_size = _cntk_py.minibatch_size_schedule_ignored_minibatch_size

    def is_sweep_based(self):
        return _cntk_py.minibatch_size_schedule_is_sweep_based(self)
    __swig_destroy__ = _cntk_py.delete_minibatch_size_schedule
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _cntk_py.new_minibatch_size_schedule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def serialize(self):
        return _cntk_py.minibatch_size_schedule_serialize(self)

    def current_version(self):
        return _cntk_py.minibatch_size_schedule_current_version(self)
    if _newclass:
        deserialize = staticmethod(_cntk_py.minibatch_size_schedule_deserialize)
    else:
        deserialize = _cntk_py.minibatch_size_schedule_deserialize

    def __eq__(self, right):
        return _cntk_py.minibatch_size_schedule___eq__(self, right)

    def transform(self, func):
        return _cntk_py.minibatch_size_schedule_transform(self, func)

    def get_minibatch_size(self):
        return _cntk_py.minibatch_size_schedule_get_minibatch_size(self)

    def set_minibatch_size(self, minibatchSize):
        return _cntk_py.minibatch_size_schedule_set_minibatch_size(self, minibatchSize)

    def __getitem__(self, count):
        return _cntk_py.minibatch_size_schedule___getitem__(self, count)
minibatch_size_schedule_swigregister = _cntk_py.minibatch_size_schedule_swigregister
minibatch_size_schedule_swigregister(minibatch_size_schedule)

def minibatch_size_schedule_deserialize(dictionary):
    return _cntk_py.minibatch_size_schedule_deserialize(dictionary)
minibatch_size_schedule_deserialize = _cntk_py.minibatch_size_schedule_deserialize

class training_double_parameter_schedule(IDictionarySerializable):
    __swig_setmethods__ = {}
    for _s in [IDictionarySerializable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, training_double_parameter_schedule, name, value)
    __swig_getmethods__ = {}
    for _s in [IDictionarySerializable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, training_double_parameter_schedule, name)
    __repr__ = _swig_repr
    full_data_sweep = _cntk_py.training_double_parameter_schedule_full_data_sweep
    ignored_minibatch_size = _cntk_py.training_double_parameter_schedule_ignored_minibatch_size

    def is_sweep_based(self):
        return _cntk_py.training_double_parameter_schedule_is_sweep_based(self)
    __swig_destroy__ = _cntk_py.delete_training_double_parameter_schedule
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _cntk_py.new_training_double_parameter_schedule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def serialize(self):
        return _cntk_py.training_double_parameter_schedule_serialize(self)

    def current_version(self):
        return _cntk_py.training_double_parameter_schedule_current_version(self)
    if _newclass:
        deserialize = staticmethod(_cntk_py.training_double_parameter_schedule_deserialize)
    else:
        deserialize = _cntk_py.training_double_parameter_schedule_deserialize

    def __eq__(self, right):
        return _cntk_py.training_double_parameter_schedule___eq__(self, right)

    def transform(self, func):
        return _cntk_py.training_double_parameter_schedule_transform(self, func)

    def __getitem__(self, count):
        return _cntk_py.training_double_parameter_schedule___getitem__(self, count)
    __swig_setmethods__["minibatch_size"] = _cntk_py.training_double_parameter_schedule_minibatch_size_set
    __swig_getmethods__["minibatch_size"] = _cntk_py.training_double_parameter_schedule_minibatch_size_get
    if _newclass:
        minibatch_size = _swig_property(_cntk_py.training_double_parameter_schedule_minibatch_size_get, _cntk_py.training_double_parameter_schedule_minibatch_size_set)
training_double_parameter_schedule_swigregister = _cntk_py.training_double_parameter_schedule_swigregister
training_double_parameter_schedule_swigregister(training_double_parameter_schedule)

def training_double_parameter_schedule_deserialize(dictionary):
    return _cntk_py.training_double_parameter_schedule_deserialize(dictionary)
training_double_parameter_schedule_deserialize = _cntk_py.training_double_parameter_schedule_deserialize

class OptionalBool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalBool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalBool, name)
    __repr__ = _swig_repr

    def reset(self):
        return _cntk_py.OptionalBool_reset(self)

    def is_initialized(self):
        return _cntk_py.OptionalBool_is_initialized(self)

    def get(self):
        return _cntk_py.OptionalBool_get(self)

    def __init__(self, *args):
        this = _cntk_py.new_OptionalBool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, value):
        return _cntk_py.OptionalBool_set(self, value)
    __swig_destroy__ = _cntk_py.delete_OptionalBool
    __del__ = lambda self: None
OptionalBool_swigregister = _cntk_py.OptionalBool_swigregister
OptionalBool_swigregister(OptionalBool)

class UserBackPropState(BackPropState):
    __swig_setmethods__ = {}
    for _s in [BackPropState]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserBackPropState, name, value)
    __swig_getmethods__ = {}
    for _s in [BackPropState]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UserBackPropState, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        create = staticmethod(_cntk_py.UserBackPropState_create)
    else:
        create = _cntk_py.UserBackPropState_create
    if _newclass:
        data = staticmethod(_cntk_py.UserBackPropState_data)
    else:
        data = _cntk_py.UserBackPropState_data
    __swig_destroy__ = _cntk_py.delete_UserBackPropState
    __del__ = lambda self: None
UserBackPropState_swigregister = _cntk_py.UserBackPropState_swigregister
UserBackPropState_swigregister(UserBackPropState)

def UserBackPropState_create(function, computeDevice, userData):
    return _cntk_py.UserBackPropState_create(function, computeDevice, userData)
UserBackPropState_create = _cntk_py.UserBackPropState_create

def UserBackPropState_data(*args):
    return _cntk_py.UserBackPropState_data(*args)
UserBackPropState_data = _cntk_py.UserBackPropState_data


Variable.__eq__ = lambda a,b: (a is not None and b is not None and Variable_eq(a,b)) or (a is None and b is None)


Constant.__eq__ = lambda a,b: (a is not None and b is not None and Variable_eq(a,b)) or (a is None and b is None)


Parameter.__eq__ = lambda a,b: (a is not None and b is not None and Variable_eq(a,b)) or (a is None and b is None)


NDShape.__eq__ = lambda a,b: (a is not None and b is not None and NDShape_eq(a,b)) or (a is None and b is None)


Axis.__eq__ = lambda a,b: (a is not None and b is not None and Axis_eq(a,b)) or (a is None and b is None)


DeviceDescriptor.__eq__ = lambda a,b: (a is not None and b is not None and DeviceDescriptor_eq(a,b)) or (a is None and b is None)


StreamInformation.__eq__ = lambda a,b: a.m_name==b.m_name and a.m_id==b.m_id and a.m_storage_format==b.m_storage_format and a.m_element_type==b.m_element_type and a.m_sample_layout.dimensions()==b.m_sample_layout.dimensions()


from .tensor import _add_tensor_ops, _add_asarray
for klass in [Function, Variable]:
    _add_tensor_ops(klass)

for klass in [Constant, Parameter, Value, NDArrayView, NDMask, MinibatchData]:
    _add_asarray(klass)

enable_reversing_tensor_shapes_in_error_messages()

# This file is compatible with both classic and new-style classes.


